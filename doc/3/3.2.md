**[本章官方翻译链接](https://docs.djangoproject.com/zh-hans/3.1/topics/db/models/)**

# 3.2 模型和数据库

A model is the single, definitive source of data about your data. It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table.

模型是唯一的，决定源数据的是你的数据。包含了你要存储数据所必要的字段和行为。通常，每个模型对应一个唯一的数据库表。

# 3.2.1 模型

模型是唯一的，决定源数据的是你的数据。包含了你要存储数据所必要的字段和行为。通常，每个模型对应一个唯一的数据库表。

The basics:

-   Each model is a Python class that subclasses django.db.models.Model.
-   Each attribute of the model represents a database field.
-   With all of this, Django gives you an automatically-generated database-access API; see Making queries.

最基本的：

-   每个模型都是一个 Python 的类， 基于 django.db.models.Model 的子类
-   每个模型的属性代表了数据库的字段
-   基于此，Django 提供给你自动生成的数据库存取 api；[查看 Making queries]()

## 快速例子

This example model defines a Person, which has a first_name and last_name:

这个例子定义了一个 Person，拥有 first_name 和 last_name 属性

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

first_name and last_name are fields of the model. Each field is specified as a class attribute, and each attribute maps to a database column.

first_name 和 last_name are 是模型的字段。每个字段都是模型的属性，每个属性对应着数据库里的列。

The above Person model would create a database table like this:

上面的 Person 模型将创建一个数据库表类似如下：

```
CREATE TABLE myapp_person (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

Some technical notes:

-   The name of the table, myapp_person, is automatically derived from some model metadata but can be over-
    ridden. See Table names for more details.
-   An id field is added automatically, but this behavior can be overridden. See Automatic primary key fields.
-   The CREATE TABLE SQL in this example is formatted using PostgreSQL syntax, but it’s worth noting Django uses SQL tailored to the database backend specified in your settings file.

技术性笔记：

-   表的名字 “myapp_person”是按照模型的元数据自动生成的，这个名字生成规则可被覆写。详情查看[Table names]()
-   id 字段将被自动添加，这个行为也是可以被覆写的。查看[Automatic primary key fields.]()
-   在这个例子中生成这个表的的 SQL 语法是 PostgreSQL ，值得注意的是 Django 使用的 SQL 是为设置文件中指定的数据库后端定制的。

## 使用模型

Once you have defined your models, you need to tell Django you’re going to use those models. Do this by editing your settings file and changing the INSTALLED_APPS setting to add the name of the module that contains your models.py.

一旦你定义你的模型，你需要告诉 Django 你将要使用这些模型。编辑 settings 文件，在 INSTALLED_APPS 配置里添加包含了 models.py 模块的名字。

For example, if the models for your application live in the module myapp.models (the package structure that is created for an application by the manage.py startapp script),INSTALLED_APPS should read,in part:

举个例子，如果应用程序的模型位于 myapp.models 模块中(这个包的结构是一个应用程序，由 manage.py startapp 脚本所创建)，在 INSTALLED_APPS 配置

```python
INSTALLED_APPS = [ #...
'myapp',
#...
]

```

When you add new apps to INSTALLED_APPS,be sure to run manage.py migrate,optionally making migrations for them first with manage.py makemigrations.

当你添加了一个新的 APP 到 INSTALLED_APPS，确保运行 [manage.py migrate]()，可以选择先为他们用 [manage.py makemigrations]() 做迁移。

## 字段

The most important part of a model – and the only required part of a model – is the list of database fields it defines. Fields are specified by class attributes. Be careful not to choose field names that conflict with the models API like clean, save, or delete.

模型最重要也是必须的部分————是它定义的数据库字段列表。字段由类属性指定。要注意不要使用和模型 api 冲突的名字，例如 clean、save、delete。

```python
from django.db import models
class Musician(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    instrument = models.CharField(max_length=100)

class Album(models.Model):
    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    release_date = models.DateField()
    num_stars = models.IntegerField()
```

## 字段类型

Each field in your model should be an instance of the appropriate Field class. Django uses the field class types to determine a few things:

-   The column type, which tells the database what kind of data to store (e.g. INTEGER, VARCHAR, TEXT).
-   The default HTML widget to use when rendering a form field (e.g. \<input type="text"\>, \<select\\>).
-   The minimal validation requirements, used in Django’s admin and in automatically-generated forms.

Django ships with dozens of built-in field types; you can find the complete list in the model field reference. You can easily write your own fields if Django’s built-in ones don’t do the trick; see Writing custom model fields.

在你模型里的每个字段应该是一个相应字段类的实例。Django 使用字段类的类型去决定一些事：

-   列类型，告诉数据库存储数据的类型（eg 整数，可变字符串，文本 ）
-   呈现表单字段时要使用的默认 HTML 部件(e.g. \<input type="text"\>, \<select\/>)
-   最低验证要求，使用 Django 的后台自动生成的表单

Django 有二十多个内置的字段类型，你可以在[model field reference.]()找到完整的列表，假如内置的字段不能满足你，你可以很轻易的编写自己的字段，查看[编写自定义字段]()

## 字段选项

Each field takes a certain set of field-specific arguments (documented in the model field reference). For example, CharField (and its subclasses) require a max_length argument which specifies the size of the VARCHAR database field used to store the data.

每个字段有特定的字段参数（文档在[model field reference]()）。例如，CharField（以及它的子类）必须要有一个 max_length 参数用于在数据库存储字符串数据的大小。

There’s also a set of common arguments available to all field types. All are optional. They’re fully explained in the reference, but here’s a quick summary of the most often-used ones:

所有的字段类型有通用的参数,它们都是可选的。他们的说明[在这](), 着这里我们快速介绍一下最常用的几个：

**null** If True, Django will store empty values as NULL in the database. Default is False.

**null** 假如为 True，Django 将把空的值在数据库里存储为 NULL 。 默认为 False。

blank If True, the field is allowed to be blank. Default is False.

**blank** 假如为 True，这个字段将允许为空白。默认为 False。

Note that this is different than null. null is purely database-related, whereas blank is validation-related. If a field has blank=True, form validation will allow entry of an empty value. If a field has blank=False, the field will be required.

注意这和 NUll 是不一样的。null 纯粹与数据库相关，但 blank 与验证相关。将如字段 blank=True,表单验证的时候将允许填入空的值。将如为 blank= false，这个字段将必填。

choices A sequence of 2-tuples to use as choices for this field. If this is given, the default form widget will be a select box instead of the standard text field and will limit choices to the choices given.

**choices** 这个字段是有 2 个元素的元组的数组

A choices list looks like this:

一个 choices 列表看起来像这样

```python
YEAR_IN_SCHOOL_CHOICES =[
    ('FR', 'Freshman'),
    ('SO', 'Sophomore'),
    ('JR', 'Junior'),
    ('SR', 'Senior'),
    ('GR', 'Graduate'),
]
```

---

**NOTE** A new migrationis created each time the order of choices changes.

**注意** 每次顺序的改变都会产生一个 migrationis

---

The first element in each tuple is the value that will be stored in the database. The second element is displayed by the field’s form widget.

每个元组的第一个元素是要存储在数据库里的值，第二元素为表单组件的要显示的值

Given a model instance, the display value for a field with choices can be accessed using the
get_FOO_display() method. For example:

对于一个模型实例，要显示 choices 类型的字段值可以使用 get_FOO_display()方法，例如：

```python
from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```base
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

You can also use enumeration classes to define choices in a concise way:

你也可以使用枚举类这种简易的方式来定义 choices：

```python
from django.db import models
class Runner(models.Model):
    MedalType = models.TextChoices('MedalType', 'GOLD SILVER BRONZE')
    name = models.CharField(max_length=60)
    medal = models.CharField(blank=True, choices=MedalType.choices, max_length=10)
```

Further examples are available in the model field reference.

更多列子在[model field reference]()可找到。

**default** The default value for the field. This can be a value or a callable object. If callable it will be called every time a new object is created.

**help_text** Extra “help” text to be displayed with the form widget. It’s useful for documentation even if your field isn’t used on a form.

**primary_key** If True,this field is the primary key for the model.

**default** 字段的默认值，它可以是一个值或者一个回调函数，假如是回调函数，它将在被调用时创建一个新的对象。

**help_text** 额外的“帮助”信息在表单组件显示。它对于文档很有用，即使这个字段在表单中没有被使用。

**primary_key** 假如为 true，这个字段将是这个模型的主键。

If you don’t specify primary_key=True for any fields in your model, Django will automatically add an IntegerField to hold the primary key, so you don’t need to set primary_key=True on any of your fields unless you want to override the default primary-key behavior. For more, see Automatic primary key fields.

The primary key field is read-only. If you change the value of the primary key on an existing object and then save it, a new object will be created alongside the old one. For example:

如果在你模型里所有字段都没有指定 primary_key=True，Django 将自动添加一个整数字段为主键，所以你无需为你模型的字段设定 primary_key=True，除非你想改写默认的主键行为。详情查看[ Automatic primary key fields.]()

这个主键是只读的。假如你改变一个已存在的对象的主键值并保存，一个新的对象将在旧对象的旁边被创建。例如：

```python
from django.db import models
class Fruit(models.Model):
    name = models.CharField(max_length=100, primary_key=True)
```

> \>\>\> fruit = Fruit.objects.create(name='Apple')
>
> \>\>\> fruit.name = 'Pear'
>
> \>\>\> fruit.save()
>
> \>\>\> Fruit.objects.values_list('name', flat=True)
>
> \<QuerySet \['Apple', 'Pear'\]\>

**unique** If True, this field must be unique throughout the table.

**unique** 假如为 true，这个字段在表中必须是唯一的

Again, these are just short descriptions of the most common field options. Full details can be found in the common model field option reference.

重申一下，这些仅仅是一些比较通用字段选项的简短介绍。更多详情请看[common model field option reference.]()

## 自动生成的主键字段

By default, Django gives each model the following field:

通常，Django 会给每个模型添加如下字段：

```
id = models.AutoField(primary_key=True)
```

This is an auto-incrementing primary key.

这是自动生成的主键。

If you’d like to specify a custom primary key, specify primary_key=True on one of your fields. If Django sees you’ve explicitly set Field.primary_key, it won’t add the automatic id column.

如果你想指定自定义的主键，添加 primary_key=True 到你想要的字段参数中。加入 Django 看到你设置了 Field.primary_key，它将添加到自动的 id 栏。

Each model requires exactly one field to have primary_key=True (either explicitly declared or automatically added).

每个模型必需要有一个字段设置 primary_key=True（显示声明或自动添加）。

## 详细的字段名

Each field type, except for ForeignKey, ManyToManyField and OneToOneField, takes an optional first positional argument – a verbose name. If the verbose name isn’t given, Django will automatically create it using the field’s attribute name, converting underscores to spaces.

每个字段类型，除了 ForeignKey, ManyToManyField 和 OneToOneField，都有第一个可选参数————详细说明。将如该参数没有提供，Django 将使用该字段的属性名自动创建，下划线将转变为空格。

In this example,the verbose name is "person's first name":

在这个例子中，详细说明为“person's first name”

```
first_name = models.CharField("person's first name", max_length=30)

```

In this example,the verbose name is "first name":

在这个例子中，详细说明为“first name”

```
first_name = models.CharField(max_length=30)

```

ForeignKey, ManyToManyField and OneToOneField require the first argument to be a model class, so use the verbose_name keyword argument:

ForeignKey, ManyToManyField and OneToOneField 第一个参数必填为模型类，所以详情将使用 verbose_name 关键字参数：

```python
poll = models.ForeignKey(
    Poll,
    on_delete=models.CASCADE,
    verbose_name="the related poll",
     )
sites = models.ManyToManyField(Site, verbose_name="list of sites")
place = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    verbose_name="related place",
)
```

The convention is not to capitalize the first letter of the verbose_name. Django will automatically capitalize the first letter where it needs to.

惯例来说，verbose_name 首字母不用大写。Django 会在需要的地方自动大写。

## 关系

Clearly, the power of relational databases lies in relating tables to each other. Django offers ways to define the three most common types of database relationships: many-to-one, many-to-many and one-to-one.

很显然，关系数据库的威力在于将表相互关联起来。Django 提供了定义三种常用的数据库关系的方式：many-to-one, many-to-many and one-to-one。

## 多对一关系

To define a many-to-one relationship, use django.db.models.ForeignKey. You use it just like any other Field type: by including it as a class attribute of your model.

使用 django.db.models.ForeignKey 定义多对一关系，使用这个和使用其他类型的字段一样，在你的模型里包含该字段。

ForeignKey requires a positional argument: the class to which the model is related.

ForeignKey 必填一个位置参数： 要关联的模型的类

For example, if a Car model has a Manufacturer – that is, a Manufacturer makes multiple cars but each Car
only has one Manufacturer – use the following definitions:

举个例子，假如 Car 模型有 Manufacturer(制造商)属性，Manufacturer 可以制作多个 Car，但是 Car 只能有一个制造商，使用如下定义：

```python
from django.db import models

class Manufacturer(models.Model):
    # ...
    pass
class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    # ...
```

You can also create recursive relationships (an object with a many-to-one relationship to itself) and relationships to models not yet defined; see the model field reference for details.

你可以创建[递归关联]()(与本身具有多对一关系的对象) 以及 关[联还没有定义的模型]()。详见[模型字段参考]()。

It’s suggested, but not required, that the name of a ForeignKey field (manufacturer in the example above) be the name of the model, lowercase. You can call the field whatever you want. For example:

推荐（但不是必须）ForeignKey 字段的名字为所关联模型的名字（例如上例中的 manufacturer），使用小写。当然你可以取任何名字，例如：

```
class Car(models.Model):
    company_that_makes_it = models.ForeignKey(
            Manufacturer,
            on_delete=models.CASCADE,
        )
    # ...
```

See also:

ForeignKey fields accept a number of extra arguments which are explained in the model field reference. These options help define how the relationship should work; all are optional.

ForeignKey 字段还有许多其他的额外参数，详情解释在[模型字段参考]()。这些参数定义了该关联对象该如果工作，所有参数都是可选的。

For details on accessing backwards-related objects, see the Following relationships backward example.

关于反向关联对象的细节，参见[Following relationships backward example]()。

For sample code, see the Many-to-one relationship model example.

完整代码请查看[Many-to-one relationship model example]()

## 多对多关系

To define a many-to-many relationship, use ManyToManyField. You use it just like any other Field type: by including it as a class attribute of your model.

使用 ManyToManyField 定义多对多关系，使用这个和使用其他类型的字段一样，在你的模型里包含该字段。

ManyToManyField requires a positional argument: the class to which the model is related.

ManyToManyField 必填一个位置参数：要关联的模型 class

For example, if a Pizza has multiple Topping objects – that is, a Topping can be on multiple pizzas and each
Pizza has multiple toppings – here’s how you’d represent that:

例如，Pizza 可以有多个 Topping（佐料）对象，意思是，作料可以应用在多种 pizzas 上，pizzas 可以有多种佐料，代码表示如下：

```python
from django.db import models
class Topping(models.Model):
    # ...
    pass
class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)

```

As with ForeignKey, you can also create recursive relationships (an object with a many-to-many relationship to itself) and relationships to models not yet defined.

和 ForeignKey 一样，你可以创建递归关联（和本身创建多对多的关系）和 关联还未定义的对象

It’s suggested, but not required, that the name of a ManyToManyField (toppings in the example above) be a plural describing the set of related model objects.

推荐（但不是必须）ManyToManyField 字段的名字用复数来描述所关联模型的对象（例如上例中的 toppings）。

It doesn’t matter which model has the ManyToManyField, but you should only put it in one of the models – not both.

哪个模型拥有 ManyToManyField 字段并不重要，但你要确保只有一个模型拥有 ManyToManyField 字段，而不是两个都有。

Generally, ManyToManyField instances should go in the object that’s going to be edited on a form. In the above example, toppings is in Pizza (rather than Topping having a pizzas ManyToManyField ) because it’s more natural to think about a pizza having toppings than a topping being on multiple pizzas. The way it’s set up above, the Pizza form would let users select the toppings.

通常，ManyToManyField 字段应该放在要编辑的表单实例中，在上例中，toppings 在 Pizza 中（相比 Topping 拥有 pizzas 的 ManyToManyField 字段），因为普遍认为 pizza 有 toppings，而不是 topping 作用于多个 pizzas，这个方式应用到上例中，在 Pizza 表单中将可以选择 toppings。

See the Many-to-many relationship model example for a full example.

查看 Many-to-many 关联对象的完整实例

ManyToManyField fields also accept a number of extra arguments which are explained in the model field reference. These options help define how the relationship should work; all are optional.

ManyToManyField 字段还有许多其他的额外参数，详情解释在[模型字段参考]()。这些参数定义了该关联对象该如果工作，所有参数都是可选的。

## 多对多关系的额外字段

When you’re only dealing with many-to-many relationships such as mixing and matching pizzas and toppings, a standard ManyToManyField is all you need. However, sometimes you may need to associate data with the relationship between two models.

当你处理多对多关系时仅仅混合和匹配 pizzas 和 toppings，一个 ManyToManyField 就可以搞定。然后，某些时候你可能需要混合两个关联对象的数据。

For example, consider the case of an application tracking the musical groups which musicians belong to. There is a many-to-many relationship between a person and the groups of which they are a member, so you could use a ManyToManyField to represent this relationship. However, there is a lot of detail about the membership that you might want to collect, such as the date at which the person joined the group.

例如，考虑这样一个 APP，要追踪音乐家属于哪个音乐分组。这个多对多关系介于人和分组成员，因此使用 ManyToManyField 字段表示这个关系。然而，有许多的会员详情你可能想要收集，例如这个人何时加入的这个组。

For these situations, Django allows you to specify the model that will be used to govern the many-to-many relationship. You can then put extra fields on the intermediate model. The intermediate model is associated with the ManyToManyField using the through argument to point to the model that will act as an intermediary. For our musician example, the code would look something like this:

对于这种情况，Django 允许您指定将用于管理多对多关系的模型。你可以在之后将额外的字段放在中间模型中。ManyToManyField 中使用 through 参数关联这个中间模型，回到我们这个音乐家例子，代码看起如下：

```python
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=128)
    def __str__(self):
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership')
    def __str__(self):
        return self.name

class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)
```

When you set up the intermediary model, you explicitly specify foreign keys to the models that are involved in the many-to-many relationship. This explicit declaration defines how the two models are related.

当你设置中间模型，你可以显式地为多对多关系中涉及的模型指定外键。这里显示声明了这两个模型的关系。

There are a few restrictions on the intermediate model:

-   Your intermediate model must contain one - and only one - foreign key to the source model (this would be Group in our example), or you must explicitly specify the foreign keys Django should use for the relationship using ManyToManyField.through_fields. If you have more than one foreign key and through_fields is not specified, a validation error will be raised. A similar restriction applies to the foreign key to the target model (this would be Person in our example).
-   For a model which has a many-to-many relationship to itself through an intermediary model, two foreign keys to the same model are permitted, but they will be treated as the two (different) sides of the many-to-many relationship. If there are more than two foreign keys though, you must also specify through_fields as above, or a validation error will be raised.

对于中间模型有些限制：

-   中建模型必须包含且只能包含一个指向源模型的外键(在我们这个例子是 Group),或者显式的用 ManyToManyField.through_fields 的参数指定，假如你有多个外键且没有使用 through_fields 指定，这将出现验证错误。对于指向目标模型（我们例子当中的 Person ）的外键也有同样的限制。
-   对于拥有指向自己的多对多关系模型的中间模型，允许有两个外键指向相同的模型，但这两个外健分表代表多对多关系（不同）的两端，如果超过两个外键，则必须像上面一样用 through 字段指定，否则将出现验证错误。

Now that you have set up your ManyToManyField to use your intermediary model (Membership, in this case), you’re ready to start creating some many-to-many relationships. You do this by creating instances of the intermediate model:

现在你的多对多模型有了中间件(Membership),你先在可以创建一些多对多关系了，通过创建中间件的实例：

```bash
>>> ringo = Person.objects.create(name="Ringo Starr")
>>> paul = Person.objects.create(name="Paul McCartney")
>>> beatles = Group.objects.create(name="The Beatles")
>>> m1 = Membership(person=ringo, group=beatles,
... date_joined=date(1962, 8, 16),
... invite_reason="Needed a new drummer.")
>>> m1.save()
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>]>
>>> ringo.group_set.all()
<QuerySet [<Group: The Beatles>]>
>>> m2 = Membership.objects.create(person=paul, group=beatles,date_joined=date(1960, 8, 1),
... invite_reason="Wanted to form a band.")
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>]>
```

You can also use add(), create(), or set() to create relationships, as long as you specify through_defaults for any required fields:

你也可以使用 add(), create(), or set()创建关系，只要你为必填的字段指定 through_defaults。

```bash
>>> beatles.members.add(john, through_defaults={'date_joined': date(1960, 8, 1)})
>>> beatles.members.create(name="George Harrison", through_defaults={'date_joined':date(1960, 8, 1)})
>>> beatles.members.set([john, paul, ringo, george], through_defaults={'date_joined':date(1960, 8, 1)})
```

You may prefer to create instances of the intermediate model directly.

你可能更想立即用中间模型来创建实例

If the custom through table defined by the intermediate model does not enforce uniqueness on the (model1,
model2) pair, allowing multiple values, the remove() call will remove all intermediate model instances:

如果自定义中间模型没有强制 (model1, model2) 对的唯一性，调用 remove() 方法会删除所有中间模型的实例

```bash
>>> Membership.objects.create(person=ringo, group=beatles,
... date_joined=date(1968, 9, 4),
... invite_reason="You've been gone for a month and we miss you.")
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>, <Person: Ringo Starr>]>
>>> # This deletes both of the intermediate model instances for Ringo Starr
>>> beatles.members.remove(ringo)
>>> beatles.members.all()
<QuerySet [<Person: Paul McCartney>]>
```

The clear() method can be used to remove all many-to-many relationships for an instance:

clear() 方面可以移除所有 many-to-many 关系的实例

```bash
>>> # Beatles have broken up
>>> beatles.members.clear()
>>> # Note that this deletes the intermediate model instances >>> Membership.objects.all()
<QuerySet []>
```

Once you have established the many-to-many relationships, you can issue queries. Just as with normal many-to-many relationships, you can query using the attributes of the many-to-many-related model:

一旦你创建好了 many-to-many 关系，你就可以使用查询了。仅仅是平常的 many-to-many 关系，你就可以使用多对的关联模型的属性查询：

```bash
 # Find all the groups with a member whose name starts with 'Paul'
>>> Group.objects.filter(members__name__startswith='Paul')
<QuerySet [<Group: The Beatles>]>
```

As you are using an intermediate model, you can also query on its attributes:

在使用中间模型时，还可以查询其属性：

```bash
# Find all the members of the Beatles that joined after 1 Jan 1961
>>> Person.objects.filter(
... group__name='The Beatles',
... membership__date_joined__gt=date(1961,1,1))
<QuerySet [<Person: Ringo Starr]>
```

If you need to access a membership’s information you may do so by directly querying the Membership model:

假如你需要查询会员的信息，你需要直接查询 Membership 模型

```bash
>>> ringos_membership = Membership.objects.get(group=beatles, person=ringo)
>>> ringos_membership.date_joined
datetime.date(1962, 8, 16)
>>> ringos_membership.invite_reason 'Needed a new drummer.'
```

Another way to access the same information is by querying the many-to-many reverse relationship from a Person object:

查询会员信息另一个方式是通过 Person 查询出关联的会员信息 [many-to-many reverse relationship]()

```bash
>>> ringos_membership = ringo.membership_set.get(group=beatles)
>>> ringos_membership.date_joined
datetime.date(1962, 8, 16)
>>> ringos_membership.invite_reason
'Needed a new drummer.'
```

## 一对一关系

To define a one-to-one relationship, use OneToOneField. You use it just like any other Field type: by including it as a class attribute of your model.

使用 OneToOneField 定义多对一关系，使用这个和使用其他类型的字段一样，在你的模型里包含该字段。

This is most useful on the primary key of an object when that object “extends” another object in some way.

当一个对象“继承”另一个对象时，这对这个对象的主键非常有用。

OneToOneField requires a positional argument: the class to which the model is related.

OneToOneField 必填一个位置参数，要关联模型的 class。

For example, if you were building a database of “places”, you would build pretty standard stuff such as address, phone number, etc. in the database. Then, if you wanted to build a database of restaurants on top of the places, instead of repeating yourself and replicating those fields in the Restaurant model, you could make Restaurant have a OneToOneField to Place (because a restaurant “is a” place; in fact, to handle this you’d typically use inheritance, which involves an implicit one-to-one relation).

例如，假如你正在建立一个“地点”的数据库，你会创建标准的例如地点,手机号, 等字段到数据库。然后，假如你想要构建一个基于”地点“数据库的“餐馆”数据库，你则需要将“地点”里的字段复制到”餐馆“模型中，你可以在”餐馆“模型里添加 OneToOneField 指向”地点“（因为餐馆也是地点；实际上，处理这种情况典型做法是使用继承，它包含一种隐式的 one-to-one 关系）。

As with ForeignKey, a recursive relationship can be defined and references to as-yet undefined models can be made.

与 ForeignKey 类似，自关联对象和尚未定义的模型都可以被定义。

See the One-to-one relationship model example for a full example.

查看 One-to-one 关系模型的完整例子。

OneToOneField fields also accept an optional parent_link argument.

OneToOneField 字段支持一个可选的 parent_link 参数。

OneToOneField classes used to automatically become the primary key on a model. This is no longer true (although you can manually pass in the primary_key argument if you like). Thus, it’s now possible to have multiple fields of type OneToOneField on a single model.

使用 OneToOneField 将自动的成为模型的主键，这条规则已经不再使用了（然而你可以手动的指定 primary_key 参数），因此在模型中可以有多个 OneToOneField 字段。

## 跨文件模型
