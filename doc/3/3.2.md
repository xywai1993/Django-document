**[本章官方翻译链接](https://docs.djangoproject.com/zh-hans/3.1/topics/db/models/)**

# 3.2 模型和数据库

A model is the single, definitive source of data about your data. It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table.

模型是唯一的，决定源数据的是你的数据。包含了你要存储数据所必要的字段和行为。通常，每个模型对应一个唯一的数据库表。

# 3.2.1 模型

模型是唯一的，决定源数据的是你的数据。包含了你要存储数据所必要的字段和行为。通常，每个模型对应一个唯一的数据库表。

The basics:

-   Each model is a Python class that subclasses django.db.models.Model.
-   Each attribute of the model represents a database field.
-   With all of this, Django gives you an automatically-generated database-access API; see Making queries.

最基本的：

-   每个模型都是一个 Python 的类， 基于 django.db.models.Model 的子类
-   每个模型的属性代表了数据库的字段
-   基于此，Django 提供给你自动生成的数据库存取 api；[查看 Making queries]()

## 快速例子

This example model defines a Person, which has a first_name and last_name:

这个例子定义了一个 Person，拥有 first_name 和 last_name 属性

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
```

first_name and last_name are fields of the model. Each field is specified as a class attribute, and each attribute maps to a database column.

first_name 和 last_name are 是模型的字段。每个字段都是模型的属性，每个属性对应着数据库里的列。

The above Person model would create a database table like this:

上面的 Person 模型将创建一个数据库表类似如下：

```
CREATE TABLE myapp_person (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

Some technical notes:

-   The name of the table, myapp_person, is automatically derived from some model metadata but can be over-
    ridden. See Table names for more details.
-   An id field is added automatically, but this behavior can be overridden. See Automatic primary key fields.
-   The CREATE TABLE SQL in this example is formatted using PostgreSQL syntax, but it’s worth noting Django uses SQL tailored to the database backend specified in your settings file.

技术性笔记：

-   表的名字 “myapp_person”是按照模型的元数据自动生成的，这个名字生成规则可被覆写。详情查看[Table names]()
-   id 字段将被自动添加，这个行为也是可以被覆写的。查看[Automatic primary key fields.]()
-   在这个例子中生成这个表的的 SQL 语法是 PostgreSQL ，值得注意的是 Django 使用的 SQL 是为设置文件中指定的数据库后端定制的。

## 使用模型

Once you have defined your models, you need to tell Django you’re going to use those models. Do this by editing your settings file and changing the INSTALLED_APPS setting to add the name of the module that contains your models.py.

一旦你定义你的模型，你需要告诉 Django 你将要使用这些模型。编辑 settings 文件，在 INSTALLED_APPS 配置里添加包含了 models.py 模块的名字。

For example, if the models for your application live in the module myapp.models (the package structure that is created for an application by the manage.py startapp script),INSTALLED_APPS should read,in part:

举个例子，如果应用程序的模型位于 myapp.models 模块中(这个包的结构是一个应用程序，由 manage.py startapp 脚本所创建)，在 INSTALLED_APPS 配置

```python
INSTALLED_APPS = [ #...
'myapp',
#...
]

```

When you add new apps to INSTALLED_APPS,be sure to run manage.py migrate,optionally making migrations for them first with manage.py makemigrations.

当你添加了一个新的 APP 到 INSTALLED_APPS，确保运行 [manage.py migrate]()，可以选择先为他们用 [manage.py makemigrations]() 做迁移。

## 字段

The most important part of a model – and the only required part of a model – is the list of database fields it defines. Fields are specified by class attributes. Be careful not to choose field names that conflict with the models API like clean, save, or delete.

模型最重要也是必须的部分————是它定义的数据库字段列表。字段由类属性指定。要注意不要使用和模型 api 冲突的名字，例如 clean、save、delete。

```python
from django.db import models
class Musician(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    instrument = models.CharField(max_length=100)

class Album(models.Model):
    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    release_date = models.DateField()
    num_stars = models.IntegerField()
```

## 字段类型

Each field in your model should be an instance of the appropriate Field class. Django uses the field class types to determine a few things:

-   The column type, which tells the database what kind of data to store (e.g. INTEGER, VARCHAR, TEXT).
-   The default HTML widget to use when rendering a form field (e.g. \<input type="text"\>, \<select\\>).
-   The minimal validation requirements, used in Django’s admin and in automatically-generated forms.

Django ships with dozens of built-in field types; you can find the complete list in the model field reference. You can easily write your own fields if Django’s built-in ones don’t do the trick; see Writing custom model fields.

在你模型里的每个字段应该是一个相应字段类的实例。Django 使用字段类的类型去决定一些事：

-   列类型，告诉数据库存储数据的类型（eg 整数，可变字符串，文本 ）
-   呈现表单字段时要使用的默认 HTML 部件(e.g. \<input type="text"\>, \<select\/>)
-   最低验证要求，使用 Django 的后台自动生成的表单

Django 有二十多个内置的字段类型，你可以在[model field reference.]()找到完整的列表，假如内置的字段不能满足你，你可以很轻易的编写自己的字段，查看[编写自定义字段]()

## 字段选项

Each field takes a certain set of field-specific arguments (documented in the model field reference). For example, CharField (and its subclasses) require a max_length argument which specifies the size of the VARCHAR database field used to store the data.

每个字段有特定的字段参数（文档在[model field reference]()）。例如，CharField（以及它的子类）必须要有一个 max_length 参数用于在数据库存储字符串数据的大小。

There’s also a set of common arguments available to all field types. All are optional. They’re fully explained in the reference, but here’s a quick summary of the most often-used ones:

所有的字段类型有通用的参数,它们都是可选的。他们的说明[在这](), 着这里我们快速介绍一下最常用的几个：

**null** If True, Django will store empty values as NULL in the database. Default is False.

**null** 假如为 True，Django 将把空的值在数据库里存储为 NULL 。 默认为 False。

blank If True, the field is allowed to be blank. Default is False.

**blank** 假如为 True，这个字段将允许为空白。默认为 False。

Note that this is different than null. null is purely database-related, whereas blank is validation-related. If a field has blank=True, form validation will allow entry of an empty value. If a field has blank=False, the field will be required.

注意这和 NUll 是不一样的。null 纯粹与数据库相关，但 blank 与验证相关。将如字段 blank=True,表单验证的时候将允许填入空的值。将如为 blank= false，这个字段将必填。

choices A sequence of 2-tuples to use as choices for this field. If this is given, the default form widget will be a select box instead of the standard text field and will limit choices to the choices given.

**choices** 这个字段是有 2 个元素的元组的数组

A choices list looks like this:

一个 choices 列表看起来像这样

```python
YEAR_IN_SCHOOL_CHOICES =[
    ('FR', 'Freshman'),
    ('SO', 'Sophomore'),
    ('JR', 'Junior'),
    ('SR', 'Senior'),
    ('GR', 'Graduate'),
]
```

---

**NOTE** A new migrationis created each time the order of choices changes.

**注意** 每次顺序的改变都会产生一个 migrationis

---

The first element in each tuple is the value that will be stored in the database. The second element is displayed by the field’s form widget.

每个元组的第一个元素是要存储在数据库里的值，第二元素为表单组件的要显示的值

Given a model instance, the display value for a field with choices can be accessed using the
get_FOO_display() method. For example:

对于一个模型实例，要显示 choices 类型的字段值可以使用 get_FOO_display()方法，例如：

```python
from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
```

```base
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size
'L'
>>> p.get_shirt_size_display()
'Large'
```

You can also use enumeration classes to define choices in a concise way:

你也可以使用枚举类这种简易的方式来定义 choices：

```python
from django.db import models
class Runner(models.Model):
    MedalType = models.TextChoices('MedalType', 'GOLD SILVER BRONZE')
    name = models.CharField(max_length=60)
    medal = models.CharField(blank=True, choices=MedalType.choices, max_length=10)
```

Further examples are available in the model field reference.

更多列子在[model field reference]()可找到。

**default** The default value for the field. This can be a value or a callable object. If callable it will be called every time a new object is created.

**help_text** Extra “help” text to be displayed with the form widget. It’s useful for documentation even if your field isn’t used on a form.

**primary_key** If True,this field is the primary key for the model.

**default** 字段的默认值，它可以是一个值或者一个回调函数，假如是回调函数，它将在被调用时创建一个新的对象。

**help_text** 额外的“帮助”信息在表单组件显示。它对于文档很有用，即使这个字段在表单中没有被使用。

**primary_key** 假如为 true，这个字段将是这个模型的主键。

If you don’t specify primary_key=True for any fields in your model, Django will automatically add an IntegerField to hold the primary key, so you don’t need to set primary_key=True on any of your fields unless you want to override the default primary-key behavior. For more, see Automatic primary key fields.

The primary key field is read-only. If you change the value of the primary key on an existing object and then save it, a new object will be created alongside the old one. For example:

如果在你模型里所有字段都没有指定 primary_key=True，Django 将自动添加一个整数字段为主键，所以你无需为你模型的字段设定 primary_key=True，除非你想改写默认的主键行为。详情查看[ Automatic primary key fields.]()

这个主键是只读的。假如你改变一个已存在的对象的主键值并保存，一个新的对象将在旧对象的旁边被创建。例如：

```python
from django.db import models
class Fruit(models.Model):
    name = models.CharField(max_length=100, primary_key=True)
```

> \>\>\> fruit = Fruit.objects.create(name='Apple')
>
> \>\>\> fruit.name = 'Pear'
>
> \>\>\> fruit.save()
>
> \>\>\> Fruit.objects.values_list('name', flat=True)
>
> \<QuerySet \['Apple', 'Pear'\]\>

**unique** If True, this field must be unique throughout the table.

**unique** 假如为 true，这个字段在表中必须是唯一的

Again, these are just short descriptions of the most common field options. Full details can be found in the common model field option reference.

重申一下，这些仅仅是一些比较通用字段选项的简短介绍。更多详情请看[common model field option reference.]()

## 自动生成的主键字段

By default, Django gives each model the following field:

通常，Django 会给每个模型添加如下字段：

```
id = models.AutoField(primary_key=True)
```

This is an auto-incrementing primary key.

这是自动生成的主键。

If you’d like to specify a custom primary key, specify primary_key=True on one of your fields. If Django sees you’ve explicitly set Field.primary_key, it won’t add the automatic id column.

如果你想指定自定义的主键，添加 primary_key=True 到你想要的字段参数中。加入 Django 看到你设置了 Field.primary_key，它将添加到自动的 id 栏。

Each model requires exactly one field to have primary_key=True (either explicitly declared or automatically added).

每个模型必需要有一个字段设置 primary_key=True（显示声明或自动添加）。

## 详细的字段名

Each field type, except for ForeignKey, ManyToManyField and OneToOneField, takes an optional first positional argument – a verbose name. If the verbose name isn’t given, Django will automatically create it using the field’s attribute name, converting underscores to spaces.

每个字段类型，除了 ForeignKey, ManyToManyField 和 OneToOneField，都有第一个可选参数————详细说明。将如该参数没有提供，Django 将使用该字段的属性名自动创建，下划线将转变为空格。

In this example,the verbose name is "person's first name":

在这个例子中，详细说明为“person's first name”

```
first_name = models.CharField("person's first name", max_length=30)

```

In this example,the verbose name is "first name":

在这个例子中，详细说明为“first name”

```
first_name = models.CharField(max_length=30)

```

ForeignKey, ManyToManyField and OneToOneField require the first argument to be a model class, so use the verbose_name keyword argument:

ForeignKey, ManyToManyField and OneToOneField 第一个参数必填为模型类，所以详情将使用 verbose_name 关键字参数：

```python
poll = models.ForeignKey(
    Poll,
    on_delete=models.CASCADE,
    verbose_name="the related poll",
     )
sites = models.ManyToManyField(Site, verbose_name="list of sites")
place = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    verbose_name="related place",
)
```

The convention is not to capitalize the first letter of the verbose_name. Django will automatically capitalize the first letter where it needs to.

惯例来说，verbose_name 首字母不用大写。Django 会在需要的地方自动大写。

## 关系

Clearly, the power of relational databases lies in relating tables to each other. Django offers ways to define the three most common types of database relationships: many-to-one, many-to-many and one-to-one.

很显然，关系数据库的威力在于将表相互关联起来。Django 提供了定义三种常用的数据库关系的方式：many-to-one, many-to-many and one-to-one。

## 多对一关系

To define a many-to-one relationship, use django.db.models.ForeignKey. You use it just like any other Field type: by including it as a class attribute of your model.

使用 django.db.models.ForeignKey 定义多对一关系，使用这个和使用其他类型的字段一样，在你的模型里包含该字段。

ForeignKey requires a positional argument: the class to which the model is related.

ForeignKey 必填一个位置参数： 要关联的模型的类

For example, if a Car model has a Manufacturer – that is, a Manufacturer makes multiple cars but each Car
only has one Manufacturer – use the following definitions:

举个例子，假如 Car 模型有 Manufacturer(制造商)属性，Manufacturer 可以制作多个 Car，但是 Car 只能有一个制造商，使用如下定义：

```python
from django.db import models

class Manufacturer(models.Model):
    # ...
    pass
class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    # ...
```

You can also create recursive relationships (an object with a many-to-one relationship to itself) and relationships to models not yet defined; see the model field reference for details.

你可以创建[递归关联]()(与本身具有多对一关系的对象) 以及 关[联还没有定义的模型]()。详见[模型字段参考]()。

It’s suggested, but not required, that the name of a ForeignKey field (manufacturer in the example above) be the name of the model, lowercase. You can call the field whatever you want. For example:

推荐（但不是必须）ForeignKey 字段的名字为所关联模型的名字（例如上例中的 manufacturer），使用小写。当然你可以取任何名字，例如：

```
class Car(models.Model):
    company_that_makes_it = models.ForeignKey(
            Manufacturer,
            on_delete=models.CASCADE,
        )
    # ...
```

See also:

ForeignKey fields accept a number of extra arguments which are explained in the model field reference. These options help define how the relationship should work; all are optional.

ForeignKey 字段还有许多其他的额外参数，详情解释在[模型字段参考]()。这些参数定义了该关联对象该如果工作，所有参数都是可选的。

For details on accessing backwards-related objects, see the Following relationships backward example.

关于反向关联对象的细节，参见[Following relationships backward example]()。

For sample code, see the Many-to-one relationship model example.

完整代码请查看[Many-to-one relationship model example]()

## 多对多关系

To define a many-to-many relationship, use ManyToManyField. You use it just like any other Field type: by including it as a class attribute of your model.

使用 ManyToManyField 定义多对多关系，使用这个和使用其他类型的字段一样，在你的模型里包含该字段。

ManyToManyField requires a positional argument: the class to which the model is related.

ManyToManyField 必填一个位置参数：要关联的模型 class

For example, if a Pizza has multiple Topping objects – that is, a Topping can be on multiple pizzas and each
Pizza has multiple toppings – here’s how you’d represent that:

例如，Pizza 可以有多个 Topping（佐料）对象，意思是，作料可以应用在多种 pizzas 上，pizzas 可以有多种佐料，代码表示如下：

```python
from django.db import models
class Topping(models.Model):
    # ...
    pass
class Pizza(models.Model):
    # ...
    toppings = models.ManyToManyField(Topping)

```

As with ForeignKey, you can also create recursive relationships (an object with a many-to-many relationship to itself) and relationships to models not yet defined.

和 ForeignKey 一样，你可以创建递归关联（和本身创建多对多的关系）和 关联还未定义的对象

It’s suggested, but not required, that the name of a ManyToManyField (toppings in the example above) be a plural describing the set of related model objects.

推荐（但不是必须）ManyToManyField 字段的名字用复数来描述所关联模型的对象（例如上例中的 toppings）。

It doesn’t matter which model has the ManyToManyField, but you should only put it in one of the models – not both.

哪个模型拥有 ManyToManyField 字段并不重要，但你要确保只有一个模型拥有 ManyToManyField 字段，而不是两个都有。

Generally, ManyToManyField instances should go in the object that’s going to be edited on a form. In the above example, toppings is in Pizza (rather than Topping having a pizzas ManyToManyField ) because it’s more natural to think about a pizza having toppings than a topping being on multiple pizzas. The way it’s set up above, the Pizza form would let users select the toppings.

通常，ManyToManyField 字段应该放在要编辑的表单实例中，在上例中，toppings 在 Pizza 中（相比 Topping 拥有 pizzas 的 ManyToManyField 字段），因为普遍认为 pizza 有 toppings，而不是 topping 作用于多个 pizzas，这个方式应用到上例中，在 Pizza 表单中将可以选择 toppings。

See the Many-to-many relationship model example for a full example.

查看 Many-to-many 关联对象的完整实例

ManyToManyField fields also accept a number of extra arguments which are explained in the model field reference. These options help define how the relationship should work; all are optional.

ManyToManyField 字段还有许多其他的额外参数，详情解释在[模型字段参考]()。这些参数定义了该关联对象该如果工作，所有参数都是可选的。

## 多对多关系的额外字段

When you’re only dealing with many-to-many relationships such as mixing and matching pizzas and toppings, a standard ManyToManyField is all you need. However, sometimes you may need to associate data with the relationship between two models.

当你处理多对多关系时仅仅混合和匹配 pizzas 和 toppings，一个 ManyToManyField 就可以搞定。然后，某些时候你可能需要混合两个关联对象的数据。

For example, consider the case of an application tracking the musical groups which musicians belong to. There is a many-to-many relationship between a person and the groups of which they are a member, so you could use a ManyToManyField to represent this relationship. However, there is a lot of detail about the membership that you might want to collect, such as the date at which the person joined the group.

例如，考虑这样一个 APP，要追踪音乐家属于哪个音乐分组。这个多对多关系介于人和分组成员，因此使用 ManyToManyField 字段表示这个关系。然而，有许多的会员详情你可能想要收集，例如这个人何时加入的这个组。

For these situations, Django allows you to specify the model that will be used to govern the many-to-many relationship. You can then put extra fields on the intermediate model. The intermediate model is associated with the ManyToManyField using the through argument to point to the model that will act as an intermediary. For our musician example, the code would look something like this:

对于这种情况，Django 允许您指定将用于管理多对多关系的模型。你可以在之后将额外的字段放在中间模型中。ManyToManyField 中使用 through 参数关联这个中间模型，回到我们这个音乐家例子，代码看起如下：

```python
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=128)
    def __str__(self):
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership')
    def __str__(self):
        return self.name

class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)
```

When you set up the intermediary model, you explicitly specify foreign keys to the models that are involved in the many-to-many relationship. This explicit declaration defines how the two models are related.

当你设置中间模型，你可以显式地为多对多关系中涉及的模型指定外键。这里显示声明了这两个模型的关系。

There are a few restrictions on the intermediate model:

-   Your intermediate model must contain one - and only one - foreign key to the source model (this would be Group in our example), or you must explicitly specify the foreign keys Django should use for the relationship using ManyToManyField.through_fields. If you have more than one foreign key and through_fields is not specified, a validation error will be raised. A similar restriction applies to the foreign key to the target model (this would be Person in our example).
-   For a model which has a many-to-many relationship to itself through an intermediary model, two foreign keys to the same model are permitted, but they will be treated as the two (different) sides of the many-to-many relationship. If there are more than two foreign keys though, you must also specify through_fields as above, or a validation error will be raised.

对于中间模型有些限制：

-   中建模型必须包含且只能包含一个指向源模型的外键(在我们这个例子是 Group),或者显式的用 ManyToManyField.through_fields 的参数指定，假如你有多个外键且没有使用 through_fields 指定，这将出现验证错误。对于指向目标模型（我们例子当中的 Person ）的外键也有同样的限制。
-   对于拥有指向自己的多对多关系模型的中间模型，允许有两个外键指向相同的模型，但这两个外健分表代表多对多关系（不同）的两端，如果超过两个外键，则必须像上面一样用 through 字段指定，否则将出现验证错误。

Now that you have set up your ManyToManyField to use your intermediary model (Membership, in this case), you’re ready to start creating some many-to-many relationships. You do this by creating instances of the intermediate model:

现在你的多对多模型有了中间件(Membership),你先在可以创建一些多对多关系了，通过创建中间件的实例：

```bash
>>> ringo = Person.objects.create(name="Ringo Starr")
>>> paul = Person.objects.create(name="Paul McCartney")
>>> beatles = Group.objects.create(name="The Beatles")
>>> m1 = Membership(person=ringo, group=beatles,
... date_joined=date(1962, 8, 16),
... invite_reason="Needed a new drummer.")
>>> m1.save()
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>]>
>>> ringo.group_set.all()
<QuerySet [<Group: The Beatles>]>
>>> m2 = Membership.objects.create(person=paul, group=beatles,date_joined=date(1960, 8, 1),
... invite_reason="Wanted to form a band.")
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>]>
```

You can also use add(), create(), or set() to create relationships, as long as you specify through_defaults for any required fields:

你也可以使用 add(), create(), or set()创建关系，只要你为必填的字段指定 through_defaults。

```bash
>>> beatles.members.add(john, through_defaults={'date_joined': date(1960, 8, 1)})
>>> beatles.members.create(name="George Harrison", through_defaults={'date_joined':date(1960, 8, 1)})
>>> beatles.members.set([john, paul, ringo, george], through_defaults={'date_joined':date(1960, 8, 1)})
```

You may prefer to create instances of the intermediate model directly.

你可能更想立即用中间模型来创建实例

If the custom through table defined by the intermediate model does not enforce uniqueness on the (model1,
model2) pair, allowing multiple values, the remove() call will remove all intermediate model instances:

如果自定义中间模型没有强制 (model1, model2) 对的唯一性，调用 remove() 方法会删除所有中间模型的实例

```bash
>>> Membership.objects.create(person=ringo, group=beatles,
... date_joined=date(1968, 9, 4),
... invite_reason="You've been gone for a month and we miss you.")
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>, <Person: Ringo Starr>]>
>>> # This deletes both of the intermediate model instances for Ringo Starr
>>> beatles.members.remove(ringo)
>>> beatles.members.all()
<QuerySet [<Person: Paul McCartney>]>
```

The clear() method can be used to remove all many-to-many relationships for an instance:

clear() 方面可以移除所有 many-to-many 关系的实例

```bash
>>> # Beatles have broken up
>>> beatles.members.clear()
>>> # Note that this deletes the intermediate model instances >>> Membership.objects.all()
<QuerySet []>
```

Once you have established the many-to-many relationships, you can issue queries. Just as with normal many-to-many relationships, you can query using the attributes of the many-to-many-related model:

一旦你创建好了 many-to-many 关系，你就可以使用查询了。仅仅是平常的 many-to-many 关系，你就可以使用多对的关联模型的属性查询：

```bash
 # Find all the groups with a member whose name starts with 'Paul'
>>> Group.objects.filter(members__name__startswith='Paul')
<QuerySet [<Group: The Beatles>]>
```

As you are using an intermediate model, you can also query on its attributes:

在使用中间模型时，还可以查询其属性：

```bash
# Find all the members of the Beatles that joined after 1 Jan 1961
>>> Person.objects.filter(
... group__name='The Beatles',
... membership__date_joined__gt=date(1961,1,1))
<QuerySet [<Person: Ringo Starr]>
```

If you need to access a membership’s information you may do so by directly querying the Membership model:

假如你需要查询会员的信息，你需要直接查询 Membership 模型

```bash
>>> ringos_membership = Membership.objects.get(group=beatles, person=ringo)
>>> ringos_membership.date_joined
datetime.date(1962, 8, 16)
>>> ringos_membership.invite_reason 'Needed a new drummer.'
```

Another way to access the same information is by querying the many-to-many reverse relationship from a Person object:

查询会员信息另一个方式是通过 Person 查询出关联的会员信息 [many-to-many reverse relationship]()

```bash
>>> ringos_membership = ringo.membership_set.get(group=beatles)
>>> ringos_membership.date_joined
datetime.date(1962, 8, 16)
>>> ringos_membership.invite_reason
'Needed a new drummer.'
```

## 一对一关系

To define a one-to-one relationship, use OneToOneField. You use it just like any other Field type: by including it as a class attribute of your model.

使用 OneToOneField 定义多对一关系，使用这个和使用其他类型的字段一样，在你的模型里包含该字段。

This is most useful on the primary key of an object when that object “extends” another object in some way.

当一个对象“继承”另一个对象时，这对这个对象的主键非常有用。

OneToOneField requires a positional argument: the class to which the model is related.

OneToOneField 必填一个位置参数，要关联模型的 class。

For example, if you were building a database of “places”, you would build pretty standard stuff such as address, phone number, etc. in the database. Then, if you wanted to build a database of restaurants on top of the places, instead of repeating yourself and replicating those fields in the Restaurant model, you could make Restaurant have a OneToOneField to Place (because a restaurant “is a” place; in fact, to handle this you’d typically use inheritance, which involves an implicit one-to-one relation).

例如，假如你正在建立一个“地点”的数据库，你会创建标准的例如地点,手机号, 等字段到数据库。然后，假如你想要构建一个基于”地点“数据库的“餐馆”数据库，你则需要将“地点”里的字段复制到”餐馆“模型中，你可以在”餐馆“模型里添加 OneToOneField 指向”地点“（因为餐馆也是地点；实际上，处理这种情况典型做法是使用继承，它包含一种隐式的 one-to-one 关系）。

As with ForeignKey, a recursive relationship can be defined and references to as-yet undefined models can be made.

与 ForeignKey 类似，自关联对象和尚未定义的模型都可以被定义。

See the One-to-one relationship model example for a full example.

查看 One-to-one 关系模型的完整例子。

OneToOneField fields also accept an optional parent_link argument.

OneToOneField 字段支持一个可选的 parent_link 参数。

OneToOneField classes used to automatically become the primary key on a model. This is no longer true (although you can manually pass in the primary_key argument if you like). Thus, it’s now possible to have multiple fields of type OneToOneField on a single model.

使用 OneToOneField 将自动的成为模型的主键，这条规则已经不再使用了（然而你可以手动的指定 primary_key 参数），因此在模型中可以有多个 OneToOneField 字段。

## 跨文件模型

It’s perfectly OK to relate a model to one from another app. To do this, import the related model at the top of the file where your model is defined. Then, refer to the other model class wherever needed. For example:

关联另一个 APP 的模型当然也是可以的。要这么做的话首先要从定义这个模型的地方导入这个待关联的模型，然后就可以用这个模型做你想做的事了，例如：

```python
from django.db import models
from geography.models import ZipCode

class Restaurant(models.Model):
     # ...
    zip_code = models.ForeignKey( ZipCode,on_delete=models.SET_NULL, blank=True,null=True, )
```

## 字段命名限制

Django places some restrictions on model field names:

Django 的字段命名有一些限制：

1. A field name cannot be a Python reserved word, because that would result in a Python syntax error. For example:
   字段名不能是 Python 内置关键字，因为这将引发 Python 语法错误。例如：
    ```python
    class Example(models.Model):
        pass = models.IntegerField() # 'pass'是关键字
    ```

2.A field name cannot contain more than one underscore in a row, due to the way Django’s query lookup syntax works. For example:

字段名不能使用一个以上的下划线，这个是 Django 的查询语法，例如：

```Python
 class Example(models.Model):
    foo__bar = models.IntegerField() # 'foo__bar' 有两个下划线

```

3. A field name cannot end with an underscore, for similar reasons.

字段名不能以下划线结尾，原因同上。

These limitations can be worked around, though, because your field name doesn’t necessarily have to match your database column name. See the db_column option.

但是，这些限制是可以被解决的，因为你的字段名不必和数据库列名匹配，查看[db_column]()选项。

SQL reserved words, such as join, where or select, are allowed as model field names, because Django escapes all database table names and column names in every underlying SQL query. It uses the quoting syntax of your particular database engine.

例如 join, where , select 这些 SQL 保留字是可以作为字段名的，因为 Django 在每个底层 SQL 查询中转义所有数据库表名和列名。它使用特定数据库引擎的引用语法。

## 自定义字段类型

If one of the existing model fields cannot be used to fit your purposes, or if you wish to take advantage of some less common database column types, you can create your own field class. Full coverage of creating your own fields is provided in Writing custom model fields.

假如现有的模型字段不能满足你的需求，或者你想使用一些不太通用的数据库类型，那么你可以创建你自己的字段类，在这[Writing custom model fields]()查看更多创建字段的例子。

## 元数据选项

Give your model metadata by using an inner class Meta,like so:

通过使用内置的 class Meta 给你的模型添加元数据，例如：

```python
from django.db import models
class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"
```

Model metadata is “anything that’s not a field”, such as ordering options (ordering), database table name (db_table), or human-readable singular and plural names (verbose_name and verbose_name_plural). None are required,and adding class Meta to a model is completely optional.

模型元数据即"任何不是字段的东西"，例如排序选项(ordering)，数据库表名(db_table),可读性的单复数名(verbose_name 和 verbose_name_plural)，全都不是必填，添加 class Meta 到模型也是完全可选的。

A complete list of all possible Meta options can be found in the model option reference.

[model option reference]()有完整可用的 Meta 选项列表可供参考。

## Model attributes 模型属性

**objects** The most important attribute of a model is the Manager. It’s the interface through which database query operations are provided to Django models and is used to retrieve the instances from the database. If no custom Manager is defined, the default name is objects. Managers are only accessible via model classes, not the model instances.

**objects** 模型最重要的属性是 Manager，它是一个连接数据库查询与模型的一个接口，返回一个数据库实例。假如自定义 Manager 没有定义，则默认名为 objects。Managers 只能使用在 model classes，不能是模型实例。

## Model methods 模型方法

Define custom methods on a model to add custom “row-level” functionality to your objects. Whereas Manager methods are intended to do “table-wide” things, model methods should act on a particular model instance.

在模型上为对象添加自定义“行级别”的方法。尽管 Manager 方法计划是做”表级别“的事情，但模型方法也应该作用于特定的模型实例。

This is a valuable technique for keeping business logic in one place – the model.

这是一种保持业务逻辑在模型中的一种很有用的技巧。

For example, this model has a few custom methods:

例如，这个模型有一些自定义方法：

```python
from django.db import models
class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):
        "Returns the person's full name."
        return '%s %s' % (self.first_name, self.last_name)
```

The last method in this example is a property.

这个例子中，最后一个方法是一个属性。

The model instance reference has a complete list of methods automatically given to each model. You can override most of these – see overriding predefined model methods, below – but there are a couple that you’ll almost always want to define:

[模型实例参考]()有[模型内置方法]()的完整列表。你可以覆写大部分方法——查看[覆写预定义的模型方法](),下面这些大部分都会想要自定义：

**\_\_str\_\_** () A Python “magic method” that returns a string representation of any object. This is what Python and Django will use whenever a model instance needs to be coerced and displayed as a plain string. Most notably, this happens when you display an object in an interactive console or in the admin.

**\_\_str\_\_**() 是 Python 的一个”魔法方法“，他会返回模型的字符串表示。每当 Python 和 Django 在需要显示模型实例为文本字符串时都将使用这个方法。

You’ll always want to define this method; the default isn’t very helpful at all.

你应该始终定义这个方法，默认的实在没啥帮助。

get_absolute_url() This tells Django how to calculate the URL for an object. Django uses this in its admin interface, and any time it needs to figure out a URL for an object.

Any object that has a URL that uniquely identifies it should define this method.

get_absolute_url() 告诉 Django 该如果计算对象的 URL，Django 使用这个方法在 admin 接口里，或是其他需要弄清对象 URL 的时候。

任何具有唯一标识它的 URL 的对象都应该定义此方法。

## Overriding predefined model methods 覆写预定义模型方法

There’s another set of model methods that encapsulate a bunch of database behavior that you’ll want to customize. In particular you’ll often want to change the way save() and delete() work.

You’re free to override these methods (and any other model method) to alter behavior.

还有一个 [模型方法]() 的集合，包含了一些你可能自定义的数据库行为，在实际使用中，你可能会经常的修改 save()和 delete()的工作方式。

你可以很轻易的覆写这些方法（包括其他模型方法）去改变其行为。

A classic use-case for overriding the built-in methods is if you want something to happen whenever you save an object. For example (see save() for documentation of the parameters it accepts):

假如你想在保存对象的时候做点什么，看看下面这个覆写内置方法的类使用案例。（查看文档了解 save()方法的相关参数):

```python
from django.db import models
class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()
    def save(self, *args, **kwargs):
        do_something()
        super().save(*args, **kwargs) # Call the "real" save() method.
        do_something_else()
```

你也可以阻止保存：

```python
from django.db import models
    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, *args, **kwargs):
            if self.name == "Yoko Ono's blog":
                return # Yoko shall never have her own blog!
            else:
                super().save(*args, **kwargs) # Call the "real" save() method.

```

It’s important to remember to call the super class method–that’s that super().save(\*args, \*\*kwargs)business – to ensure that the object still gets saved into the database. If you forget to call the superclass method, the default behavior won’t happen and the database won’t get touched.

最重要的不要忘记调用 super 方法，这里是 super().save(\*args, \*\*kwargs)，以确保对象依然可以保存到数据库，假如你忘记调用 super 方法，则默认的行为则不会发生，数据库也不会保存。

It’s also important that you pass through the arguments that can be passed to the model method – that’s what the \*args, \*\*kwargs bit does. Django will, from time to time, extend the capabilities of built-in model methods, adding new arguments. If you use \*args, \*\*kwargs in your method definitions, you are guaranteed that your code will automatically support those arguments when they are added.

同时传递模型方法接受的参数也很重要—— *args, \*\*kwargs 会接受这些参数。Django 会不时地扩展模型内置方法的功能，也会添加新参数。如果你在重写的方法中使用了 *args, \*\*kwargs，这将确保你的方法能接受这些新加的参数。

---

**Overridden model methods are not called on bulk operations**

Note that the delete() method for an object is not necessarily called when deleting objects in bulk using a QuerySet or as a result of a cascading delete. To ensure customized delete logic gets executed, you can use pre_delete and/or post_delete signals.

Unfortunately, there isn’t a workaround when creating or updating objects in bulk, since none of save(), pre_save, and post_save are called.

---

---

**覆写模型方法不会在批量操作中被调用**

请注意，当使用 QuerySet 批量删除对象或作为级联删除的结果时，不必调用对象的 delete（）方法。为了确保自定义的 delete 执行，你可以使用 pre_delete 和/或 post_delete 信号.

不幸的是，批量 creating 和 updating 操作不支持上述操作，因为这两种操作未调用 save()、pre_save 、 post_save。

---

## Executing custom SQL 执行自定义 SQL

Another common pattern is writing custom SQL statements in model methods and module-level methods. For more details on using raw SQL, see the documentation on using raw SQL.

另一个常见模式是在模型方法和模块级别的方法中编写自定义 SQL 协议。更多使用行 SQL，查看[using raw SQL]()

## Model inheritance 模型继承

Model inheritance in Django works almost identically to the way normal class inheritance works in Python, but the basics at the beginning of the page should still be followed. That means the base class should subclass django.db. models.Model.

Django 的模型继承方式和 Python 的类继承方式几乎一样，但也要循序本页开头提到的基本规则。意思就是这些类必须是 django.db. models.Model 的子类。

The only decision you have to make is whether you want the parent models to be models in their own right (with their own database tables), or if the parents are just holders of common information that will only be visible through the child models.

你只需要决定父类模型是否需要拥有它们的权利（拥有它们的数据表），或者父类仅作为承载仅子类中可见的公共信息的载体。

There are three styles of inheritance that are possible in Django.

在 Django 中有三种继承风格。

1. Often, you will just want to use the parent class to hold information that you don’t want to have to type out for each child model. This class isn’t going to ever be used in isolation, so Abstract base classes are what you’re after.
2. If you’re subclassing an existing model (perhaps something from another application entirely) and want each model to have its own database table, Multi-table inheritance is the way to go.
3. Finally, if you only want to modify the Python-level behavior of a model, without changing the models fields in any way, you can use Proxy models.
