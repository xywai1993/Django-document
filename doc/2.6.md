# 2.6 编写你第一个 Django 应用，第四部分

[官方翻译链接](https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial04/)

This tutorial begins where Tutorial 3 left off. We’re continuing the Web-poll application and will focus on form processing and cutting down our code.

该教程开始于教程第三部分的结尾。我们继续 web 投票程序并且专注于表单进程以及精简我们的代码。

---

**哪里获取帮助**

如果在阅读本教程遇到困难，请移步常见问题的“获得帮助”部分

---

## 2.6.1 Write a minimal form（编写一个精简表单）

Let’s update our poll detail template (“polls/detail.html”) from the last tutorial, so that the template contains an HTML \<form\> element:

让我们更新上个教程的 poll 详情模板(“polls/detail.html”)，模板添加一个 HTML\<form\>标签：

Listing 29: polls/templates/polls/detail.html

```HTML
<h1>{{ question.question_text }}</h1>
{% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}
<form action="{% url 'polls:vote' question.id %}" method="post"> {% csrf_token %}
{% for choice in question.choice_set.all %}
    <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
    <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
{% endfor %}
<input type="submit" value="Vote">
</form>
```

A quick rundown:

-   The above template displays a radio button for each question choice. The value of each radio button is the
    associated question choice’s ID. The name of each radio button is "choice". That means, when somebody
    selects one of the radio buttons and submits the form, it’ll send the POST data choice=# where # is the ID of
    the selected choice. This is the basic concept of HTML forms.
-   We set the form’s action to {% url 'polls:vote' question.id %}, and we set
    method="post". Using method="post" (as opposed to method="get") is very important, because the act of submitting this form will alter data server-side. Whenever you create a form that alters data
    server-side, use method="post". This tip isn’t specific to Django; it’s good Web development practice in
    general.
-   forloop.counter indicates how many times the for tag has gone through its loop
-   Since we’re creating a POST form (which can have the effect of modifying data), we need to worry about Cross
    Site Request Forgeries. Thankfully, you don’t have to worry too hard, because Django comes with a helpful
    system for protecting against it. In short, all POST forms that are targeted at internal URLs should use the {%
    csrf_token %} template tag.

快速总结:

-   上面的模板循环显示了每个问题选项的单选按钮。每个单选按钮的值是关联的问题选项 id。每个单选按钮的 button 都是“choice”。意思是当用户选中了一个单选按钮并且提交了表单，将会发送 post 数据 choice=选择的选项 id。这些是 HTML 表单的基本概念。
-   我们设置了表单的 action 为{% url 'polls:vote' question.id %}以及 method='post'。使用 method=“post”（与其相对的是 method="get"）是非常重要的，因为这个提交行为会改变服务的的数据，无论何时你想创建一个改变服务端数据的表单，请使用 method=“post”。这个技巧不是 Django 特有的，这是优秀 web 开发的最佳实践。
-   forloop.counter 表示当前循环了多少次
-   由于我们正在创建 post 表单（可以修改数据）,我们需要防止跨站点请求伪造。谢天谢地，你不用太过担心，因为 Django 附带非常有用的系统防止发生跨站点请求伪造。简而言之，所有针对内部 url 的 post 表单都使用{% csrf_token %}模板标签

Now, let’s create a Django view that handles the submitted data and does something with it. Remember, in Tutorial 3,
we created a URLconf for the polls application that includes this line:

现在，让我们创建一个能处理提交数据的 Django 视图。记住，在教程 3，我们创建了 polls 应用程序的 URLconf ,包含了这行：

Listing 30: polls/urls.py

```
path('<int:question_id>/vote/', views.vote, name='vote'),
```

We also created a dummy implementation of the vote() function. Let’s create a real version. Add the following to
polls/views.py:

我们也创建了一个没啥用处的 vote()方法。让我们创建一个真正的版本。添加如下代码到 polls/views.py：

Listing 31: polls/views.py

```python
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from .models import Choice, Question

# ...
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
            return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
            })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
```

This code includes a few things we haven’t covered yet in this tutorial:

这些代码包含了在本教程中还没涉及的一些内容：

-   request.POST is a dictionary-like object that lets you access submitted data by key name. In this case,
    request.POST['choice'] returns the ID of the selected choice, as a string. request.POST values are
    always strings.

    Note that Django also provides request.GET for accessing GET data in the same way – but we’re explicitly
    using request.POST in our code, to ensure that data is only altered via a POST call.

-   request.POST 是一个类字典对象，我们用它通过 key name 访问提交的数据。在这例子中，request.POST['choice']返回被选的 choice id,它是一个字符串。request.POST 的值总是字符串。

-   request.POST['choice'] will raise KeyError if choice wasn’t provided in POST data. The above
    code checks for KeyError and redisplays the question form with an error message if choice isn’t given.
-   假如在 POST data 中没有提交 choice，request.POST['choice']将抛出 KeyError。上面的代码检测 KeyError，假如 choice 没有获取到将重新显示 question 表单并伴随着错误信息。
