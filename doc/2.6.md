# 2.6 编写你第一个 Django 应用，第四部分

[官方翻译链接](https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial04/)

This tutorial begins where Tutorial 3 left off. We’re continuing the Web-poll application and will focus on form processing and cutting down our code.

该教程开始于教程第三部分的结尾。我们继续 web 投票程序并且专注于表单进程以及精简我们的代码。

---

**哪里获取帮助**

如果在阅读本教程遇到困难，请移步常见问题的“获得帮助”部分

---

## 2.6.1 Write a minimal form（编写一个精简表单）

Let’s update our poll detail template (“polls/detail.html”) from the last tutorial, so that the template contains an HTML \<form\> element:

让我们更新上个教程的 poll 详情模板(“polls/detail.html”)，模板添加一个 HTML\<form\>标签：

Listing 29: polls/templates/polls/detail.html

```HTML
<h1>{{ question.question_text }}</h1>
{% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}
<form action="{% url 'polls:vote' question.id %}" method="post"> {% csrf_token %}
{% for choice in question.choice_set.all %}
    <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
    <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
{% endfor %}
<input type="submit" value="Vote">
</form>
```

A quick rundown:

-   The above template displays a radio button for each question choice. The value of each radio button is the
    associated question choice’s ID. The name of each radio button is "choice". That means, when somebody
    selects one of the radio buttons and submits the form, it’ll send the POST data choice=# where # is the ID of
    the selected choice. This is the basic concept of HTML forms.
-   We set the form’s action to {% url 'polls:vote' question.id %}, and we set
    method="post". Using method="post" (as opposed to method="get") is very important, because the act of submitting this form will alter data server-side. Whenever you create a form that alters data
    server-side, use method="post". This tip isn’t specific to Django; it’s good Web development practice in
    general.
-   forloop.counter indicates how many times the for tag has gone through its loop
-   Since we’re creating a POST form (which can have the effect of modifying data), we need to worry about Cross
    Site Request Forgeries. Thankfully, you don’t have to worry too hard, because Django comes with a helpful
    system for protecting against it. In short, all POST forms that are targeted at internal URLs should use the {%
    csrf_token %} template tag.

快速总结:

-   上面的模板循环显示了每个问题选项的单选按钮。每个单选按钮的值是关联的问题选项 id。每个单选按钮的 name 都是“choice”。意思是当用户选中了一个单选按钮并且提交了表单，将会发送 post 数据 choice=选择的选项 id。这些是 HTML 表单的基本概念。
-   我们设置了表单的 action 为{% url 'polls:vote' question.id %}以及 method='post'。使用 method=“post”（与其相对的是 method="get"）是非常重要的，因为这个提交行为会改变服务的的数据，无论何时你想创建一个改变服务端数据的表单，请使用 method=“post”。这个技巧不是 Django 特有的，这是优秀 web 开发的最佳实践。
-   forloop.counter 表示当前循环了多少次
-   由于我们正在创建 post 表单（可以修改数据）,我们需要防止跨站点请求伪造。谢天谢地，你不用太过担心，因为 Django 附带非常有用的系统防止发生跨站点请求伪造。简而言之，所有针对内部 url 的 post 表单都使用{% csrf_token %}模板标签

Now, let’s create a Django view that handles the submitted data and does something with it. Remember, in Tutorial 3,
we created a URLconf for the polls application that includes this line:

现在，让我们创建一个能处理提交数据的 Django 视图。记住，在教程 3，我们创建了 polls 应用程序的 URLconf ,包含了这行：

Listing 30: polls/urls.py

```
path('<int:question_id>/vote/', views.vote, name='vote'),
```

We also created a dummy implementation of the vote() function. Let’s create a real version. Add the following to
polls/views.py:

我们也创建了一个没啥用处的 vote()方法。让我们创建一个真正的版本。添加如下代码到 polls/views.py：

Listing 31: polls/views.py

```python
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from .models import Choice, Question

# ...
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
            return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
            })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
```

This code includes a few things we haven’t covered yet in this tutorial:

这些代码包含了在本教程中还没涉及的一些内容：

-   request.POST is a dictionary-like object that lets you access submitted data by key name. In this case,
    request.POST['choice'] returns the ID of the selected choice, as a string. request.POST values are
    always strings.

    Note that Django also provides request.GET for accessing GET data in the same way – but we’re explicitly
    using request.POST in our code, to ensure that data is only altered via a POST call.

-   request.POST 是一个类字典对象，我们用它通过 key name 访问提交的数据。在这例子中，request.POST['choice']返回被选的 choice id,它是一个字符串。request.POST 的值总是字符串。

    注意，Django 也提供 request.GET 用同样的方式去查询 GET 数据，但在我们的代码中我们很明确的使用了 request.POST，确保数据只能通过 post 方法改动。

-   request.POST['choice'] will raise KeyError if choice wasn’t provided in POST data. The above
    code checks for KeyError and redisplays the question form with an error message if choice isn’t given.
-   假如在 POST data 中没有提交 choice，request.POST['choice']将抛出 KeyError。上面的代码检测 KeyError，假如 choice 没有获取到将重新显示 question 表单并伴随着错误信息。
-   After incrementing the choice count, the code returns an HttpResponseRedirect rather than a normal HttpResponse. HttpResponseRedirect takes a single argument: the URL to which the user will be redirected (see the following point for how we construct the URL in this case).

As the Python comment above points out, you should always return an HttpResponseRedirect after successfully dealing with POST data. This tip isn’t specific to Django; it’s good Web development practice in general.

-   增加选择的数量后，代码返回一个 HttpResponseRedirect 而不是常规的 HttpResponse。HttpResponseRedirect 使用一个参数：你将要重定向的 URL(往下看我们如何构造这个案例的 URL)

    正如上述 Python 注释所提到的，你应该在处理 post data 成功之后总是返回一个 HttpResponseRedirect。这个技巧不是 Django 特有的，这是优秀 web 开发的最佳实践。

-   We are using the reverse() function in the HttpResponseRedirect constructor in this example. This function helps avoid having to hardcode a URL in the view function. It is given the name of the view that we want to pass control to and the variable portion of the URL pattern that points to that view. In this case, using the URLconf we set up in Tutorial 3, this reverse() call will return a string like
-   在这个案例中，我们在 HttpResponseRedirect 构造函数 中使用 reverse()方法，这个方法避免在视图方法内硬编码 URL。它需要我们给出我们想要跳转的视图的名字和该视图所对应的 URL 模式中需要给该视图提供的参数。在这个案例中，使用我们在教程 3 配置过的 URLconf，reverse()将返回一个这样的字符串

```
'/polls/3/results/'
```

where the 3 is the value of question.id. This redirected URL will then call the 'results' view to display the final page.

这里的 3 是 question.id 的值。重定向的 URL 将调用'results'视图来显示最终的页面。

As mentioned in Tutorial 3, request is an HttpRequest object. For more on HttpRequest objects, see the request and response documentation.

教程 3 中提到，request 是一个 HttpRequest 对象。更多关于 HttpRequest 对象的内容，请查看 [request and response documentation]()

After somebody votes in a question, the vote() view redirects to the results page for the question. Let’s write that view:

当用户在某个问题内投票了，vote()视图将重定向到该问题的结果页面。让我们编写一下这个视图：

Listing 32: polls/views.py

```python
from django.shortcuts import get_object_or_404, render

def results(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/results.html', {'question': question})
```

This is almost exactly the same as the detail() view from Tutorial 3. The only difference is the template name. We’ll fix this redundancy later.

和教程 3 中的 detail()视图几乎一模一样。唯一不同的是模板那么。稍后我们将解决这个冗余问题。

Now, create a polls/results.html template:

现在创建一个 polls/results.html 模板：

Listing 33: polls/templates/polls/results.html

```html
<h1>{{ question.question_text }}</h1>
<ul>
    {% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
    {% endfor %}
</ul>
<a href="{% url 'polls:detail' question.id %}">Vote again?</a>
```

Now, go to /polls/1/ in your browser and vote in the question. You should see a results page that gets updated each time you vote. If you submit the form without having chosen a choice, you should see the error message.

现在，浏览器输入/polls/1/然后给这问题投票。你应该可以看到更新了你投票次数的结果界面。如果你没有选择选项就提交表单，你将看到错误信息。

---

Note: The code for our vote() view does have a small problem. It first gets the selected_choice object from the database, then computes the new value of votes, and then saves it back to the database. If two users of your website try to vote at exactly the same time, this might go wrong: The same value, let’s say 42, will be retrieved for votes. Then, for both users the new value of 43 is computed and saved, but 44 would be the expected value.
This is called a race condition. If you are interested, you can read Avoiding race conditions using F() to learn how you can solve this issue.

注意：我们的 vote()视图代码还有一些小问题。第一次从数据库获取 selected_choice 对象，计算新的投票值，然后保存到数据库中。假如两个用户访问你的网站并且恰好同时投票，这将会出现问题：从数据库取回相同的值为 42，投票后为 43，然后，2 个用户的新值都计算为 43 并且保存，但是 44 才是正确的值。

这个现象成为竞争条件。如果你感兴趣，可以阅读 [Avoiding race conditions using F()]() (避免竞争条件使用 F())学习如何解决该议题

---
