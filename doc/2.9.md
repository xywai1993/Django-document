# 2.9 编写你第一个 Django 应用，第七部分

[官方翻译链接](https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial07/)

本教程开始于教程 六 的结尾。我们继续构建 Web-poll 程序，并专注于自动生成的管理后台，我们在教程 2 有讨论过这部分。

---

**哪里获取帮助**

如果在阅读本教程遇到困难，请移步常见问题的[“获得帮助”]()部分

---

## 2.9.1 自定义管理表单

通过使用 admin.site.register(Question)注册 Question 模型，Django 可以构建默认的表单结构。通常情况下，你会想要自定义后台的外观和工作方式，你可以在注册对象的时候填一些参数告诉 Django 你想要做的。

让我们通过重新排列编辑表单中的字段来了解其工作原理。替换这一行 admin.site. register(Question)如下：

Listing 49: polls/admin.py

```python
from django.contrib import admin
from .models import Question
class QuestionAdmin(admin.ModelAdmin):
    fields = ['pub_date', 'question_text']

admin.site.register(Question, QuestionAdmin)
```

You’ll follow this pattern – create a model admin class, then pass it as the second argument to admin.site.
register() – any time you need to change the admin options for a model.
你将按照这个模式——创建一个模型的后台 class，然后把它作为 admin.site.register()的第二个参数，任何时候你都可以为模型改变后台选项。

This particular change above makes the “Publication date” come before the “Question” field:
这个特定更改使得“Publication date”位于 “Question”字段之前：

图略

This isn’t impressive with only two fields, but for admin forms with dozens of fields, choosing an intuitive order is an important usability detail.

对于 2 个字段来说，这个操作好像没啥用，但是对于多个后台表单字段来说，选择直观的顺序是一个重要的实用性细节。

And speaking of forms with dozens of fields, you might want to split the form up into fieldsets:

说回多个字段的表单问题，你也许想拆分表单为表单集：

Listing 50: polls/admin.py

```python
from django.contrib import admin
from .models import Question
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [ (None, {'fields': ['question_text']}),
    ('Date information', {'fields': ['pub_date']}),
    ]
admin.site.register(Question, QuestionAdmin)
```

The first element of each tuple in fieldsets is the title of the fieldset. Here’s what our form looks like now:

fieldset 为一个元组数组，元组的第一个元素为表单集的标题。我们的表单的看起来：

图略

## 2.9.2 添加关联对象

OK, we have our Question admin page, but a Question has multiple Choices, and the admin page doesn’t display
choices.

我们有了问题管理页面，但是一个问题有多个选项，但是管理界面没有显示选项。

ok.

There are two ways to solve this problem. The first is to register Choice with the admin just as we did with
Question:

有两个方法解决这个问题。第一个方法是注册 Choice 到管理后台，就像我们注册 Question 一样：

Listing 51: polls/admin.py

```python
from django.contrib import admin
from .models import Choice, Question
# ...
admin.site.register(Choice)
```

Now “Choices” is an available option in the Django admin. The “Add choice” form looks like this:

现在“Choices”在后台是可以用的了。“Add choice”表单看起来像这样：

图略

In that form, the “Question” field is a select box containing every question in the database. Django knows that a
ForeignKey should be represented in the admin as a <select> box. In our case, only one question exists at this
point.

在这个表单中，“Question”字段是一个下拉选择框，包含了数据库里所有的 question。django 知道这是一个关联字段，在后台表现为一个<select>表单。在我们这个例子中，只有一个 question 存在。
