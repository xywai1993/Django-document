# 2.4 编写你第一个Django应用，第二部分
本教程从第一部分的结尾处开始。我们将设置数据库，创建第一个模型，并且快速介绍Django自动生成的管理站点

******
__哪里获取帮助__

如果在阅读本教程遇到困难，请移步常见问题的“获得帮助”部分
******

# 2.4.1 数据库设置
现在，打开mysite/settings.py。这是一个普通的Python模块，带有模块级变量的Django设置。

通常，配置使用SQLite,假如刚开始用数据库，或者只是出于兴趣尝试Django，SQLite是个很好的选择。SQLite包含在Python中，所以你不需要安装任何东西去支持你的数据库。当你开始一个实际项目时，你想要使用更多可扩展的数据库，例如 PostgreSQL，已避免切换数据库的难题。

假如你希望使用其他的数据库，安装合适的database bindings ，并改变DATABASES 'default'项的键值去匹配你的数据库连接设置
- ENGINE(引擎)：'django.db.backends.sqlite3', 'django.db.backends.postgresql', 'django.db.backends.mysql',  'django.db.backends.oracle'.其他可用的后端也可以
- NAME(名称):这是你数据库的名字，假如你使用SQLite，这数据库将是你电脑上的一个文件，在这种情况下，NAME必须是完整的绝对路径，包括该文件的文件名。默认值，BASE_DIR / 'db.sqlite3'，将在你项目目录下存储此文件。

假如你不使用SQLite作为你的数据库，必须额外设置USER(用户名)，PASSWORD(密码)，HOST(主机).更多详情，请参考DATABASES文档

*******
__其他数据库相比SQLite__

假如你使用除SQLite之外的数据库，确保你创建了数据库这一点，你可以通过在你的数据库交互式命令行中使用 "CREATE DATABASE database_name;" 命令来完成这件事。

同样要确保数据库用户提供 mysite/settings.py具有“create database”（创建数据库的权限）的权限，允许其自动创建“ test database ”供之后的教程使用

如果你使用SQLite，你事先不用创建任何东西——在需要的时候这数据库文件将自动创建。
*******

在编辑mysite/settings.py之前，先设置TIME_ZONE(时区).

注意，关注一下在文件最上方的INSTALLED_APPS(注册APP) 。它包括了所有会在你Django中启动的应用实例，APP可以再许多的项目中使用，并且可以打包和发布给其他的项目使用。

通常，INSTALLED_APPS包含如下APP，他们全部来自Django：
- django.contrib.admin – 管理站点，很快你讲使用它
- django.contrib.auth – 用户认证系统.
- django.contrib.contenttypes –  内容类型框架
- django.contrib.sessions – 会话框架
- django.contrib.messages – 消息框架
- django.contrib.staticfiles – 静态文件管理框架

这些应用程序为了方便常见任务而被默认包含。


其中一些应用程序使用至少一个数据库表，当我们使用他们之前需要在数据库中创建表，为了这么做，运行如下命令：
```shell
$ python manage.py migrate
```
迁移命令检查INSTALLED_APPS设置，根据mysite/settings.py文件的数据库设置以及应用程序附带的数据库迁移文件创建必要的数据库表(稍后我们将介绍).每个数据库迁移操作的信息都会在终端看到。如果你感兴趣，运行你命令行的终端，并输入 \dt (PostgreSQL)， SHOW TABLES; (MariaDB,MySQL)， .schema (SQLite)或者 SELECT TABLE_NAME FROM USER_TABLES; (Oracle) 来看看 Django 到底创建了哪些表。

******
__写给极简主义者__

像我们在上面说的，对于常见的任务，默认的应用程序被启用，但不是每个人都需要它，如果你不需要某些或全部。可以在运行migrate之前注释或者在 INSTALLED_APPS中删掉相应的行。migrate命令只会运行迁移在INSTALLED_APPS里的APP。
******

# 2.4.2 创建模型
现在我们将定义你的模型——本质是数据库层添加元数据

******
__哲学__

模型是有关唯一，确定的事实来源。它包含你存储数据的必要的字段和行为。Django遵DIY原理，它的目标是定义一次数据模型并从中自动派生数据。
它包含数据迁移，不像Ruby之于Rails，举个例子，迁移完全由你的模型字段中派生，它也是一个历史记录，Django可以滚动的更新你的数据库模式去匹配你当前的模型
******


在我们的投票程序中，我们将创建两个模型：问题和选项。问题模型有问题和发布日期。选择模型有2个字段:选项的文本字段和投票记录。每个选项与问题模型关联。这些概念表现为Python的类。编辑 polls/models.py如下：

清单 11: polls/models.py
```python
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200) 
    pub_date = models.DateTimeField('date published')
class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE) 
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```

在这里，每个模型表现为django.db.models.Model的子类。每个模型有许多的类变量，每个都表示为数据库的字段。

每个字段都表示为字段类的实例。例如，CharField 为字符字段，DateTimeField为日期字段。它告诉Django每个字段的数据类型

每个字段的实例名(例如question_text 和 pub_date)是字段的名字，采用对机器友好的格式。你可以在Python中使用这些值，并且你的数据库将它们作为列名。

你可以使用可选的位置参数来为字段命名一个人类可读的名字。这个功能在很多 Django 内部组成部分中都被使用了，而且作为文档的一部分。如果字段没有提供，Django将使用机器可读的名字。在这个例子中，我们仅定义了Question的人类可读名字。pub_date 和其他的字段机器可读将作为人类可读名。

一些字段的类是必填参数，例如，CharField,必填一个max_length参数，他们不仅仅使用在数据库模型中，也用在验证，很快我们将看到

字段也可以有多种可选参数，在这个例子中，我们在votes设置default=0。最后，注意，使用ForeignKey定义了关系它告诉Django每个Choice都关联单个Question。Django支持所有的数据库关系模型：多对一，多对多，一对一。


# 2.4.3 激活模型

少量的模型代码告诉了Django大量的信息。基于此，Django将：
- 为APP创建数据库模型(CREATE TABLE statements)
- 为Question 和 Choice对象创建Python数据库存取api
  
但是第一步我们要告诉我们的项目polls程序已经安装

***********
__哲学__

Django的程序是“可插拔的”：你可以将APP用在许多项目里，你可以发布APP，因为它没有绑定到当前安装的Django上
***********


为了包含APP到我们的项目中，我们需要添加一个引用到配置类的INSTALLED_APPS设置里。 poll配置的类在polls/apps.py文件。所以点式路径是“polls.apps.PollsConfig”。编辑mysite/settings.py路径并且添加点式路径到INSTALLED_APPS里，看起来像下面这样：

清单12: mysite/settings.py
```python
INSTALLED_APPS = [ 
    'polls.apps.PollsConfig', 
    'django.contrib.admin', 
    'django.contrib.auth', 
    'django.contrib.contenttypes', 
    'django.contrib.sessions', 
    'django.contrib.messages', 
    'django.contrib.staticfiles',
]
```

现在Django知道要包含poll程序。让我们运行其他命令：
```shell
$ python manage.py makemigrations polls
```

你可以看到类似如下的输出：
```shell
Migrations for 'polls': polls/migrations/0001_initial.py
- Create model Question 
- Create model Choice
```


通过运行makemigrations命令，Django将坚持你在你模型中做的一些改变（在这个例子中，你创建了新的模型），并且把修改存储为迁移。



迁移是 Django 对于模型定义（也就是你的数据库结构）的变化的储存形式——他们是在硬上的一些文件。你可以阅读你新模型的迁移记录如果你想的话，他们是文件 polls/migrations/0001_initial.py 。别担心，你不必每次都阅读迁移命令，他们被设计为人类可编辑的，这方便你想要手动调整Django的处理方式


这个命令是migrate ，为你运行迁移，并且自动管理你数据库模式，不就我们将用到，首先，让我们看看migration运行时会执行哪些SQL命令。sqlmigrate命令需要迁移对象的名词并且返回他们的SQL语句：
```shell
python manage.py sqlmigrate polls 0001
```
你应该会看到类似的输出（我们格式化了可阅读的格式）:
```
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" serial NOT NULL PRIMARY KEY, 
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" serial NOT NULL PRIMARY KEY, 
    "choice_text" varchar(200) NOT NULL, 
    "votes" integer NOT NULL, 
    "question_id" integer NOT NULL
);
ALTER TABLE "polls_choice"
ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id") 
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id"); 

COMMIT;
```

Note the following:
• The exact output will vary depending on the database you are using. The example above is generated for PostgreSQL.
• Table names are automatically generated by combining the name of the app (polls) and the lowercase name of the model – question and choice. (You can override this behavior.)
• Primary keys (IDs) are added automatically. (You can override this, too.)
• By convention, Django appends "_id" to the foreign key field name. (Yes, you can override this, as well.)
• The foreign key relationship is made explicit by a FOREIGN KEY constraint. Don’t worry about the DEFERRABLE parts; it’s telling PostgreSQL to not enforce the foreign key until the end of the transaction.
• It’s tailored to the database you’re using,sodatabase-specificfieldtypessuchasauto_increment(MySQL), serial (PostgreSQL), or integer primary key autoincrement (SQLite) are handled for you au- tomatically. Same goes for the quoting of field names – e.g., using double quotes or single quotes.
• The sqlmigrate command doesn’t actually run the migration on your database - instead, it prints it to the screen so that you can see what SQL Django thinks is required. It’s useful for checking what Django is going to do or if you have database administrators who require SQL scripts for changes.

注意一下几点：
- 根据你使用的数据库输出相差很大，上面的例子是使用PostgreSQL的输出。
- 表的名字是自动生成的——通过结合APP名和小写模型名（你可以重写此行为）
- 主要关键字段（ID）被自动添加。（你也可以重写此行为）
- 按照惯例，Django追加“_id”到外键字段名后。(没错，你也可以重写)
- 外键关系由 FOREIGN KEY 生成。你不用关心 DEFERRABLE 部分，它只是告诉 PostgreSQL，请在事务全都执行完之后再创建外键关系。
- 生成的SQL语句是根据你所使用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment (MySQL)、 serial (PostgreSQL)和 integer primary key autoincrement (SQLite)，Django 会帮你自动处理。那些和引号相关的事情 - 例如，是使用单引号还是双引号 - 也一样会被自动处理。