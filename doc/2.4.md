# 2.4 编写你第一个 Django 应用，第二部分

本教程从第一部分的结尾处开始。我们将设置数据库，创建第一个模型，并且快速介绍 Django 自动生成的管理站点

---

**哪里获取帮助**

如果在阅读本教程遇到困难，请移步常见问题的“获得帮助”部分

---

# 2.4.1 数据库设置

现在，打开 mysite/settings.py。这是一个普通的 Python 模块，带有模块级变量的 Django 设置。

通常，配置使用 SQLite,假如刚开始用数据库，或者只是出于兴趣尝试 Django，SQLite 是个很好的选择。SQLite 包含在 Python 中，所以你不需要安装任何东西去支持你的数据库。当你开始一个实际项目时，你想要使用更多可扩展的数据库，例如 PostgreSQL，已避免切换数据库的难题。

假如你希望使用其他的数据库，安装合适的 database bindings ，并改变 DATABASES 'default'项的键值去匹配你的数据库连接设置

-   ENGINE(引擎)：'django.db.backends.sqlite3', 'django.db.backends.postgresql', 'django.db.backends.mysql', 'django.db.backends.oracle'.其他可用的后端也可以
-   NAME(名称):这是你数据库的名字，假如你使用 SQLite，这数据库将是你电脑上的一个文件，在这种情况下，NAME 必须是完整的绝对路径，包括该文件的文件名。默认值，BASE_DIR / 'db.sqlite3'，将在你项目目录下存储此文件。

假如你不使用 SQLite 作为你的数据库，必须额外设置 USER(用户名)，PASSWORD(密码)，HOST(主机).更多详情，请参考 DATABASES 文档

---

**其他数据库相比 SQLite**

假如你使用除 SQLite 之外的数据库，确保你创建了数据库这一点，你可以通过在你的数据库交互式命令行中使用 "CREATE DATABASE database_name;" 命令来完成这件事。

同样要确保数据库用户提供 mysite/settings.py 具有“create database”（创建数据库的权限）的权限，允许其自动创建“ test database ”供之后的教程使用

如果你使用 SQLite，你事先不用创建任何东西——在需要的时候这数据库文件将自动创建。

---

在编辑 mysite/settings.py 之前，先设置 TIME_ZONE(时区).

注意，关注一下在文件最上方的 INSTALLED_APPS(注册 APP) 。它包括了所有会在你 Django 中启动的应用实例，APP 可以再许多的项目中使用，并且可以打包和发布给其他的项目使用。

通常，INSTALLED_APPS 包含如下 APP，他们全部来自 Django：

-   django.contrib.admin – 管理站点，很快你讲使用它
-   django.contrib.auth – 用户认证系统.
-   django.contrib.contenttypes – 内容类型框架
-   django.contrib.sessions – 会话框架
-   django.contrib.messages – 消息框架
-   django.contrib.staticfiles – 静态文件管理框架

这些应用程序为了方便常见任务而被默认包含。

其中一些应用程序使用至少一个数据库表，当我们使用他们之前需要在数据库中创建表，为了这么做，运行如下命令：

```shell
$ python manage.py migrate
```

迁移命令检查 INSTALLED_APPS 设置，根据 mysite/settings.py 文件的数据库设置以及应用程序附带的数据库迁移文件创建必要的数据库表(稍后我们将介绍).每个数据库迁移操作的信息都会在终端看到。如果你感兴趣，运行你命令行的终端，并输入 \dt (PostgreSQL)， SHOW TABLES; (MariaDB,MySQL)， .schema (SQLite)或者 SELECT TABLE_NAME FROM USER_TABLES; (Oracle) 来看看 Django 到底创建了哪些表。

---

**写给极简主义者**

像我们在上面说的，对于常见的任务，默认的应用程序被启用，但不是每个人都需要它，如果你不需要某些或全部。可以在运行 migrate 之前注释或者在 INSTALLED_APPS 中删掉相应的行。migrate 命令只会运行迁移在 INSTALLED_APPS 里的 APP。

---

# 2.4.2 创建模型

现在我们将定义你的模型——本质是数据库层添加元数据

---

**哲学**

模型是有关唯一，确定的事实来源。它包含你存储数据的必要的字段和行为。Django 遵 DIY 原理，它的目标是定义一次数据模型并从中自动派生数据。
它包含数据迁移，不像 Ruby 之于 Rails，举个例子，迁移完全由你的模型字段中派生，它也是一个历史记录，Django 可以滚动的更新你的数据库模式去匹配你当前的模型

---

在我们的投票程序中，我们将创建两个模型：问题和选项。问题模型有问题和发布日期。选择模型有 2 个字段:选项的文本字段和投票记录。每个选项与问题模型关联。这些概念表现为 Python 的类。编辑 polls/models.py 如下：

清单 11: polls/models.py

```python
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')
class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```

在这里，每个模型表现为 django.db.models.Model 的子类。每个模型有许多的类变量，每个都表示为数据库的字段。

每个字段都表示为字段类的实例。例如，CharField 为字符字段，DateTimeField 为日期字段。它告诉 Django 每个字段的数据类型

每个字段的实例名(例如 question_text 和 pub_date)是字段的名字，采用对机器友好的格式。你可以在 Python 中使用这些值，并且你的数据库将它们作为列名。

你可以使用可选的位置参数来为字段命名一个人类可读的名字。这个功能在很多 Django 内部组成部分中都被使用了，而且作为文档的一部分。如果字段没有提供，Django 将使用机器可读的名字。在这个例子中，我们仅定义了 Question 的人类可读名字。pub_date 和其他的字段机器可读将作为人类可读名。

一些字段的类是必填参数，例如，CharField,必填一个 max_length 参数，他们不仅仅使用在数据库模型中，也用在验证，很快我们将看到

字段也可以有多种可选参数，在这个例子中，我们在 votes 设置 default=0。最后，注意，使用 ForeignKey 定义了关系它告诉 Django 每个 Choice 都关联单个 Question。Django 支持所有的数据库关系模型：多对一，多对多，一对一。

# 2.4.3 激活模型

少量的模型代码告诉了 Django 大量的信息。基于此，Django 将：

-   为 APP 创建数据库模型(CREATE TABLE statements)
-   为 Question 和 Choice 对象创建 Python 数据库存取 api

但是第一步我们要告诉我们的项目 polls 程序已经安装

---

**哲学**

Django 的程序是“可插拔的”：你可以将 APP 用在许多项目里，你可以发布 APP，因为它没有绑定到当前安装的 Django 上

---

为了包含 APP 到我们的项目中，我们需要添加一个引用到配置类的 INSTALLED_APPS 设置里。 poll 配置的类在 polls/apps.py 文件。所以点式路径是“polls.apps.PollsConfig”。编辑 mysite/settings.py 路径并且添加点式路径到 INSTALLED_APPS 里，看起来像下面这样：

清单 12: mysite/settings.py

```python
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

现在 Django 知道要包含 poll 程序。让我们运行其他命令：

```shell
$ python manage.py makemigrations polls
```

你可以看到类似如下的输出：

```shell
Migrations for 'polls': polls/migrations/0001_initial.py
- Create model Question
- Create model Choice
```

通过运行 makemigrations 命令，你将告诉 Django 你在你的模型中做了一些改变（在这个例子中，你创建了新的模型），并且把存储改为迁移。

迁移是命令是如何让 Django 存储变成你的模型（于是改变你的数据库模式）——他们是在硬盘的文件。你可以阅读你新模型的迁移记录如果你想的话，他们是文件 polls/migrations/0001_initial.py 。别担心，你不必每次都阅读迁移命令，他们被设计为人类可编辑的，这方便你想要手动调整 Django 的处理方式

这个命令是 migrate ，为你运行迁移，并且自动管理你数据库模式，不就我们将用到，首先，让我们看看 migration 运行时会执行哪些 SQL 命令。sqlmigrate 命令需要迁移对象的名词并且返回他们的 SQL 语句：

```shell
python manage.py sqlmigrate polls 0001
```

你应该会看到类似的输出（我们格式化了可阅读的格式）:

```
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" serial NOT NULL PRIMARY KEY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" serial NOT NULL PRIMARY KEY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" integer NOT NULL
);
ALTER TABLE "polls_choice"
ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```
