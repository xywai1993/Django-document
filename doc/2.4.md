# 2.4 编写你第一个Django应用，第二部分
本教程从第一部分的结尾处开始。我们将设置数据库，创建第一个模型，并且快速介绍Django自动生成的管理站点

******
__哪里获取帮助__

如果在阅读本教程遇到困难，请移步常见问题的“获得帮助”部分
******

# 2.4.1 数据库设置
现在，打开mysite/settings.py。这是一个普通的Python模块，带有模块级变量的Django设置。

通常，配置使用SQLite,假如刚开始用数据库，或者只是出于兴趣尝试Django，SQLite是个很好的选择。SQLite包含在Python中，所以你不需要安装任何东西去支持你的数据库。当你开始一个实际项目时，你想要使用更多可扩展的数据库，例如 PostgreSQL，已避免切换数据库的难题。

假如你希望使用其他的数据库，安装合适的database bindings ，并改变DATABASES 'default'项的键值去匹配你的数据库连接设置
- ENGINE(引擎)：'django.db.backends.sqlite3', 'django.db.backends.postgresql', 'django.db.backends.mysql',  'django.db.backends.oracle'.其他可用的后端也可以
- NAME(名称):这是你数据库的名字，假如你使用SQLite，这数据库将是你电脑上的一个文件，在这种情况下，NAME必须是完整的绝对路径，包括该文件的文件名。默认值，BASE_DIR / 'db.sqlite3'，将在你项目目录下存储此文件。

假如你不使用SQLite作为你的数据库，必须额外设置USER(用户名)，PASSWORD(密码)，HOST(主机).更多详情，请参考DATABASES文档

*******
__其他数据库相比SQLite__

假如你使用除SQLite之外的数据库，确保你创建了数据库这一点，你可以通过在你的数据库交互式命令行中使用 "CREATE DATABASE database_name;" 命令来完成这件事。

同样要确保数据库用户提供 mysite/settings.py具有“create database”（创建数据库的权限）的权限，允许其自动创建“ test database ”供之后的教程使用

如果你使用SQLite，你事先不用创建任何东西——在需要的时候这数据库文件将自动创建。
*******

在编辑mysite/settings.py之前，先设置TIME_ZONE(时区).

注意，关注一下在文件最上方的INSTALLED_APPS(注册APP) 。它包括了所有会在你Django中启动的应用实例，APP可以再许多的项目中使用，并且可以打包和发布给其他的项目使用。

通常，INSTALLED_APPS包含如下APP，他们全部来自Django：
- django.contrib.admin – 管理站点，很快你讲使用它
- django.contrib.auth – 用户认证系统.
- django.contrib.contenttypes –  内容类型框架
- django.contrib.sessions – 会话框架
- django.contrib.messages – 消息框架
- django.contrib.staticfiles – 静态文件管理框架

这些应用程序为了方便常见任务而被默认包含。


其中一些应用程序使用至少一个数据库表，当我们使用他们之前需要在数据库中创建表，为了这么做，运行如下命令：
```shell
$ python manage.py migrate
```
迁移命令检查INSTALLED_APPS设置，根据mysite/settings.py文件的数据库设置以及应用程序附带的数据库迁移文件创建必要的数据库表(稍后我们将介绍).每个数据库迁移操作的信息都会在终端看到。如果你感兴趣，运行你命令行的终端，并输入 \dt (PostgreSQL)， SHOW TABLES; (MariaDB,MySQL)， .schema (SQLite)或者 SELECT TABLE_NAME FROM USER_TABLES; (Oracle) 来看看 Django 到底创建了哪些表。

******
__写给极简主义者__

像我们在上面说的，对于常见的任务，默认的应用程序被启用，但不是每个人都需要它，如果你不需要某些或全部。可以在运行migrate之前注释或者在 INSTALLED_APPS中删掉相应的行。migrate命令只会运行迁移在INSTALLED_APPS里的APP。
******

# 2.4.2 创建模型
现在我们将定义你的模型——本质是数据库层添加元数据

******
__哲学__

模型是有关唯一，确定的事实来源。它包含你存储数据的必要的字段和行为。Django遵DIY原理，它的目标是定义一次数据模型并从中自动派生数据。
它包含数据迁移，不像Ruby之于Rails，举个例子，迁移完全由你的模型字段中派生，它也是一个历史记录，Django可以滚动的更新你的数据库模式去匹配你当前的模型
******


在我们的投票程序中，我们将创建两个模型：问题和选项。问题模型有问题和发布日期。选择模型有2个字段:选项的文本字段和投票记录。每个选项与问题模型关联。这些概念表现为Python的类。编辑 polls/models.py如下：

清单 11: polls/models.py
```python
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200) 
    pub_date = models.DateTimeField('date published')
class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE) 
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```

在这里，每个模型表现为django.db.models.Model的子类。每个模型有许多的类变量，每个都表示为数据库的字段。

每个字段都表示为字段类的实例。例如，CharField 为字符字段，DateTimeField为日期字段。它告诉Django每个字段的数据类型

每个字段的实例名(例如question_text 和 pub_date)是字段的名字，采用对机器友好的格式。你可以在Python中使用这些值，并且你的数据库将它们作为列名。

你可以使用可选的位置参数来为字段命名一个人类可读的名字。这个功能在很多 Django 内部组成部分中都被使用了，而且作为文档的一部分。如果字段没有提供，Django将使用机器可读的名字。在这个例子中，我们仅定义了Question的人类可读名字。pub_date 和其他的字段机器可读将作为人类可读名。

一些字段的类是必填参数，例如，CharField,必填一个max_length参数，他们不仅仅使用在数据库模型中，也用在验证，很快我们将看到

字段也可以有多种可选参数，在这个例子中，我们在votes设置default=0。最后，注意，使用ForeignKey定义了关系它告诉Django每个Choice都关联单个Question。Django支持所有的数据库关系模型：多对一，多对多，一对一。


# 2.4.3 激活模型