# 2.6 编写你第一个 Django 应用，第五部分

[官方翻译链接](https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial05/)

This tutorial begins where Tutorial 4 left off. We’ve built a Web-poll application, and we’ll now create some automated tests for it.

该教程开始于教程第四部分的结尾。我们创建了一个 Web-poll 应用程序，我们现在将为它创建一些自动化测试。

---

**哪里获取帮助**

如果在阅读本教程遇到困难，请移步常见问题的[“获得帮助”]()部分

---

## 介绍自动化测试

**What are automated tests?**

**什么是自动化测试？**

Tests are routines that check the operation of your code.

测试是检查你代码能否运行的程序。

Testing operates at different levels. Some tests might apply to a tiny detail (does a particular model method return values as expected?) while others examine the overall operation of the software (does a sequence of user inputs on the site produce the desired result?). That’s no different from the kind of testing you did earlier in Tutorial 2, using the shell to examine the behavior of a method, or running the application and entering data to check how it behaves.

测试操作有不同的等级。某些测试只关注很小的细节（例如一个特定模型的方法返回值是否符合预期？），某些只检查软件的总体能否运行（例如用户在网站的一系列输入能否产生预期的结果？）。这与你早期在教程 2 中做的那种测试没有什么不同，例如使用 shell 检查方法的行为，运行程序输入数据检查运行效果。

What’s different in automated tests is that the testing work is done for you by the system. You create a set of tests once, and then as you make changes to your app, you can check that your code still works as you originally intended, without having to perform time consuming manual testing.

自动化测试不同是系统会为你完成测试工作。当你创建了一组测试，更改你的 APP 后，可以检查你的代码是否按照最初的预期去工作，不必执行耗时的手动测试

### 为什么你需要创建测试？

So why create tests, and why now?

所以为什么创建测试，为什么现在就要？

You may feel that you have quite enough on your plate just learning Python/Django, and having yet another thing to learn and do may seem overwhelming and perhaps unnecessary. After all, our polls application is working quite happily now; going through the trouble of creating automated tests is not going to make it work any better. If creating the polls application is the last bit of Django programming you will ever do, then true, you don’t need to know how to create automated tests. But, if that’s not the case, now is an excellent time to learn.

你可能感觉你学习 Python/Django 已经足够了，再学一些新东西的话看起来有点负担过重并且没什么必要。毕竟，我们的投票程序已经工作的相当完美，创建麻烦的自动测试也不会使它工作的更好。如果用 Django 程序创建一个投票 APP 就是你唯一想做的，那么这很正确，你不需要知道如何创建自动化测试。但是，如果你不仅限于此，现在就是最好的学习时机。

### 测试将节省你的时间

Up to a certain point, ‘checking that it seems to work’ will be a satisfactory test. In a more sophisticated application, you might have dozens of complex interactions between components.

在某种程度上，“检查它是否有效”将是一个令人满意的测试。在许多复杂的应用程序中，你可能会在组件之间进行许多复杂的交互。

A change in any of those components could have unexpected consequences on the application’s behavior. Checking that it still ‘seems to work’ could mean running through your code’s functionality with twenty different variations of your test data to make sure you haven’t broken something - not a good use of your time.

对组件的任何更改都可能会对应用程序的行为产生意外的结果。检查它“是否在工作”意味着通过运行多种不同的测试数据来测试你代码的功能，以确保没有破坏某些东西——这有点浪费你的时间。

That’s especially true when automated tests could do this for you in seconds. If something’s gone wrong, tests will also assist in identifying the code that’s causing the unexpected behavior.

尤其是当自动测试能为你在几秒钟内做完这些。假如某些代码出错，测试也可以辅助你识别代码的异常行为。

Sometimes it may seem a chore to tear yourself away from your productive, creative programming work to face the unglamorous and unexciting business of writing tests, particularly when you know your code is working properly.

有时候，将自己从高效的，富有创造力的编程工作中解放出来，以面对编写测试的平淡无奇，繁琐的工作似乎很麻烦，尤其是当您知道代码工作正常时。

However, the task of writing tests is a lot more fulfilling than spending hours testing your application manually or trying to identify the cause of a newly-introduced problem.

然而，编写测试远比发费大量的时间手动测试程序或者试图弄清新引进问题发生的原因要有意义的多。

### 测试不仅仅是为了确认 bug，而是为了防止 bug

It’s a mistake to think of tests merely as a negative aspect of development.

测试仅仅是开发的对立面，这个思想是错误的。

Without tests, the purpose or intended behavior of an application might be rather opaque. Even when it’s your own code, you will sometimes find yourself poking around in it trying to find out what exactly it’s doing.

没有测试，应用程序的目的或者说预期行为是不明确的，即是是你自己的代码，有时你也会发现自己根本不知道它到底在做什么。

Tests change that; they light up your code from the inside, and when something goes wrong, they focus light on the part that has gone wrong - even if you hadn’t even realized it had gone wrong.

测试改变了这种情况，它们从内部检查你的代码，当发生一些错误时，它们将聚焦错误的部分——尽管你都没有意识到那里会有错误。

### 测试使你的代码更具吸引力

You might have created a brilliant piece of software, but you will find that many other developers will refuse to look at it because it lacks tests; without tests, they won’t trust it. Jacob Kaplan-Moss, one of Django’s original developers, says “Code without tests is broken by design.”

你也许会创建一个非常亮眼的软件，但是你会发现许多其他开发者会拒接看它一眼，因为缺少测试；没有测试，人们不信任它。 Django 的原生开发者 Jacob Kaplan-Moss 说“代码没有测试是一个糟糕的设计”

That other developers want to see tests in your software before they take it seriously is yet another reason for you to start writing tests.

其他的开发者在认真对待你的软件之前希望看到测试，这是你编写测试的另一个原因。

### 测试有助于团队合作

The previous points are written from the point of view of a single developer maintaining an application. Complex applications will be maintained by teams. Tests guarantee that colleagues don’t inadvertently break your code (and that you don’t break theirs without knowing). If you want to make a living as a Django programmer, you must be good at writing tests!

前面提到的几点都是作为单个开发人员来说的，复杂的应用程序是需要团队协作的。测试保证同事不会不经意间破坏代码（也保证你在不经意间不会破坏他们）。如果你想作为一个程序员谋生的话，你必须要擅长编写测试。

## 基本测试策略

There are many ways to approach writing tests.

有许多方式编写测试。

Some programmers follow a discipline called “test-driven development”; they actually write their tests before they write their code. This might seem counter-intuitive, but in fact it’s similar to what most people will often do anyway: they describe a problem, then create some code to solve it. Test-driven development formalizes the problem in a Python test case.

一些程序员遵循“测试驱动”，他们编写代码之前先编写测试。这看起来有点反直觉，但实际上这是大多数人都会经常做的事：他们描述问题，然后编写代码解决它。测试驱动把问题具象化为 Python 测试用例

More often, a newcomer to testing will create some code and later decide that it should have some tests. Perhaps it would have been better to write some tests earlier, but it’s never too late to get started.

更常见的情况，一个新手在编写一些代码后才觉得需要编写测试。也许更早编写会更好，但是现在写也不晚。

Sometimes it’s difficult to figure out where to get started with writing tests. If you have written several thousand lines of Python, choosing something to test might not be easy. In such a case, it’s fruitful to write your first test the next time you make a change, either when you add a new feature or fix a bug.

有些时候很难搞清楚从哪里开始写测试。如果你已编写了数千行 Python 代码，选择从某处开始测试也会不太容易。在这种情况下，编写下一个你即将改变的内容的测试是比较可行的，例如添加新功能或者解决 bug 的测试。

So let’s do that right away.
让我们开始吧。

## 2.7.3 编写第一个测试

### 我们发现了一个 bug

Fortunately, there’s a little bug in the polls application for us to fix right away: the Question. was_published_recently() method returns True if the Question was published within the last day (which is correct) but also if the Question’s pub_date field is in the future (which certainly isn’t).

幸好，在 polls 程序中这是个小 bug，让我们解决它：如果 Question 是在一天之内发布的，Question. was_published_recently()返回 True（这是正确的逻辑），但是如果 Question’s pub_date 字段在这之后也会返回 true（这是不正确的）。

Confirm the bug by using the shell to check the method on a question whose date lies in the future:

通过在 shell 中输入一天之后的日期检查 question 方法来确认这个 bug:

```shell
python manage.py shell
```

```shell
>>> import datetime
>>> from django.utils import timezone
>>> from polls.models import Question
>>> # 创建question实例，输入30天之后的日期
>>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
>>> # 是否是最近发布?
>>> future_question.was_published_recently()
True
```

Since things in the future are not ‘recent’, this is clearly wrong.

输入的日期不是最近的，这是个明显的 bug。

### 创建一个测试暴露出 bug

What we’ve just done in the shell to test for the problem is exactly what we can do in an automated test, so let’s turn that into an automated test.

刚刚我们在 shell 中为 bug 所做的测试就是我们在自动化测试中要做的，所以让我们把它转换成自动化测试。

A conventional place for an application’s tests is in the application’s tests.py file; the testing system will automatically find tests in any file whose name begins with test.

按传统来说，一个应用程序的测试应该写在 tests.py 文件里；测试系统将自动查找任何名字以 test 开头的文件测试。

Put the following in the tests.py file in the polls application:

输入如下代码到 polls 的 tests.py 文件里：

Listing 36: polls/tests.py

```python
import datetime
from django.test import TestCase
from django.utils import timezone
from .models import Question

class QuestionModelTests(TestCase):
    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() returns False for questions whose pub_date is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)

```

Here we have created a django.test.TestCase subclass with a method that creates a Question instance with a pub_date in the future. We then check the output of was_published_recently() - which ought to be False.

这里创建了一个 django.test.TestCase 子类，子类里创建了一个方法，里面有一个未来发布时间的 Question 实例。之后我们检查 was_published_recently()方法的返回值——它应该返回 False

### 运行测试

In the terminal, we can run our test:

在终端，我们运行测试：

```python
$ python manage.py test polls
```

and you’ll see something like:

你将看到类似如下输出：

```shell
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
F ====================================================================== FAIL: test_was_published_recently_with_future_question (polls.tests.
˓→QuestionModelTests) ----------------------------------------------------------------------
Traceback (most recent call last):
    File "/path/to/mysite/polls/tests.py", line 16, in test_was_published_recently_with_ ˓→future_question
    self.assertIs(future_question.was_published_recently(), False)
    AssertionError: True is not False
---------------------------------------------------------------------- Ran 1 test in 0.001s
FAILED (failures=1)
Destroying test database for alias 'default'...
```

### 不同的错误？

If instead you’re getting a NameError here, you may have missed a step in Part 2 where we added imports of datetime and timezone to polls/models.py. Copy the imports from that section, and try running your tests again.

假如你看到的是 NameError 错误，你可能在教程 2 中忘记了在 polls/models.py 中导入 datetime 和 timezone。拷贝导入的这部分，重新运行测试试试。

What happened is this:

-   manage.py test polls looked for tests in the polls application
-   it found a subclass of the django.test.TestCase class
-   it created a special database for the purpose of testing
-   it looked for test methods - ones whose names begin with test
-   in test_was_published_recently_with_future_question it created a Question instance whose pub_date field is 30 days in the future
-   ... and using the assertIs() method, it discovered that its was_published_recently() returns True, though we wanted it to return False

The test informs us which test failed and even the line on which the failure occurred.

发生了什么：

-   manage.py test polls 在 polls 应用程序里查找 test 文件
-   它找到了 django.test.TestCase 类的子类
-   它创建一个特定的数据库用于测试
-   它找以 test 开头的方法
-   在 test_was_published_recently_with_future_question 方法里创建了一个 pub_date 为 30 天后的 Question 实例
-   使用 assertIs()方法，它发现 was_published_recently()返回了 True，但是我们想要它返回 False

测试告知我们测试失败了，并且告知失败发生在哪一行

### 修复 bug

We already know what the problem is: Question.was_published_recently() should return False if its pub_date is in the future. Amend the method in models.py, so that it will only return True if the date is also in the past:

我们已经知道问题所在：假如 pub_date 是未来时间，Question.was_published_recently()应该返回 False。修改 models.py 里的方法，让日期只有发生在过去才会返回 True。

Listing 37: polls/models.py

```python
def was_published_recently(self):
    now = timezone.now()
    return now - datetime.timedelta(days=1) <= self.pub_date <= now
```

再次运行测试：

```shell
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
. ---------------------------------------------------------------------- Ran 1 test in 0.001s
OK
Destroying test database for alias 'default'...
```

After identifying a bug, we wrote a test that exposes it and corrected the bug in the code so our test passes.

确认这个 bug 后，我们编写了一个测试暴露出了这个 bug，然后编写代码更正了它，最后我们通过了测试。

Many other things might go wrong with our application in the future, but we can be sure that we won’t inadvertently reintroduce this bug, because running the test will warn us immediately. We can consider this little portion of the application pinned down safely forever.

在未来我们的程序可能会有其他的错误，但是我们可以肯定的是不会再次遇到这个 bug 了，因为一运行测试我们将立即得到警告。我们可以认定这一小块代码在应用里是永无 bug 的。
